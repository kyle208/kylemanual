---
sidebar_position: 18
---
ğŸš©å½“å‰é€šçŸ¥æ–‡ä»¶é€‚é…**Ver2.17.2**ç‰ˆæœ¬é’é¾™ï¼Œé¢æ¿è®¾ç½®æ— è§†ç‰ˆæœ¬

:::danger æœ€é‡è¦æç¤º
ğŸš©**å¿…é¡»ä¸‹è½½ç¾¤æ–‡ä»¶/æ–‡ä»¶ç³»ç»Ÿçš„ã€HPSocket4C.dllã€‘æ”¾ç½®åœ¨æ¡†æ¶æ ¹ç›®å½•ä¸‹æ‰èƒ½æ­£å¸¸ä½¿ç”¨ï¼Œå¦åˆ™æŸäº›æ¡†æ¶æ‰“å¼€æ’ä»¶å°±å´©**

æŸäº›æ¡†æ¶è‡ªå¸¦ï¼Œå¯ä¸ç®¡ï¼Œé™¤éè¿˜æœ‰å´©æºƒæç¤ºï¼Œè¯´æ˜è‡ªå¸¦çš„ç‰ˆæœ¬ä½
:::

![å›¾ç‰‡](/img/doc/é«˜çº§åŠŸèƒ½/é«˜çº§é¦–é¡µ/é’é¾™é¢æ¿.png)
### æç¤º
:::tip æç¤º1ï¼š
é»˜è®¤ç«¯å£:8090ï¼Œå¦‚éœ€æ›´æ”¹ï¼Œè‡ªè¡Œè®¾ç½®

é€šçŸ¥ç¾¤ï¼šè®¾ç½®ä½ è¦å‘é€é€šçŸ¥çš„ç¾¤å·

å›å¤å†…å®¹ï¼šè‡ªè¡Œè®¾ç½®æ˜¾ç¤ºæ ¼å¼ï¼ŒæŒ‰å˜é‡è®¾ç½®å“¦

é€šçŸ¥ç™½åå•è¯ï¼šè®¾ç½®äº†å°†åªåœ¨æœ‰æ­¤è¯ä¸‹å‘é€ï¼Œ#åˆ†å‰²å¤šä¸ªè¯ï¼Œé»˜è®¤æ‰€æœ‰é€šçŸ¥éƒ½å‘é€
:::

:::tip æç¤º2ï¼š
ã€å¯æ¨é€å…¶ä»–è‡ªå®šä¹‰å†…å®¹å“¦ï¼Œè‡ªå®šä¹‰æ¨é€æŒ‡å—ï¼šã€‘

åœ°å€ï¼šhttp://127.0.0.1:8090  [ç«¯å£å·çœ‹ä½ è®¾ç½®ï¼Œæ­¤ä¸ºæœ¬åœ°åœ°å€ï¼Œä½ å¯ä»¥å†…ç½‘ç©¿é€æ­¤åœ°å€ï¼Œå¦‚æœæ˜¯å…¬ç½‘ipï¼ŒæŒ‰ç…§å…¬ç½‘è®¾ç½®è¯•è¯•]

ç±»å‹ï¼šPOST

æäº¤å†…å®¹æ ¼å¼ï¼š
~~~
{"title":"ä½ çš„è‡ªå®šä¹‰é€šçŸ¥æ ‡é¢˜" "content":"ä½ çš„è‡ªå®šä¹‰é€šçŸ¥å†…å®¹"}
~~~
:::
:::danger æç¤º3ï¼š
é’é¾™é¢æ¿è‡ªå®šä¹‰é€šçŸ¥ç›®å‰ä¸æ”¯æŒè‡ªå®šä¹‰ï¼Œéœ€è¦ä½¿ç”¨æˆ‘æ”¹çš„ç‰ˆæœ¬ï¼Œè¯·åœ¨ç½‘ç›˜/ç¾¤æ–‡ä»¶ä¸‹è½½æ›¿æ¢ï¼Œæˆ–ä¸‹æ–¹ä»£ç å¤åˆ¶

æ›¿æ¢é’é¾™æ–‡ä»¶ã€scriptsã€‘ç›®å½•ä¸‹çš„notify.py/sendNotify.jsä¸¤ä¸ªæ–‡ä»¶

ã€configã€‘ç›®å½•ä¸‹çš„config.shæœ€ååŠ å…¥
~~~
export export WEBHOOK_URL=""  #å¡«å†™ä½ çš„è‡ªå®šä¹‰é€šçŸ¥åœ°å€
~~~

æœ‰äº›è„šæœ¬é‡Œä¹Ÿæœ‰è¿™ä¸ªæ–‡ä»¶ï¼Œè¯·ä¹Ÿæ›¿æ¢æœ€å¥½
![å›¾ç‰‡](/img/doc/é«˜çº§åŠŸèƒ½/é«˜çº§é¦–é¡µ/é’é¾™é¢æ¿1.png)
:::

:::tip  æç¤º4ï¼š
ç³»ç»Ÿæ–‡ä»¶é€šçŸ¥ï¼Œè¯·å¦‚å›¾è®¾ç½®å³å¯
![å›¾ç‰‡](/img/doc/é«˜çº§åŠŸèƒ½/é«˜çº§é¦–é¡µ/é’é¾™é¢æ¿2.png)
~~~
webhookBodyï¼šå¤åˆ¶å¦‚ä¸‹å†…å®¹å³å¯

title:$title
content:$content
~~~
:::

### notify.pyæ–‡ä»¶å†…å®¹
~~~py notify.py
#!/usr/bin/env python3
# _*_ coding:utf-8 _*_
import base64
import hashlib
import hmac
import json
import os
import re
import threading
import time
import urllib.parse
import smtplib
from email.mime.text import MIMEText
from email.header import Header
from email.utils import formataddr

import requests

# åŸå…ˆçš„ print å‡½æ•°å’Œä¸»çº¿ç¨‹çš„é”
_print = print
mutex = threading.Lock()


# å®šä¹‰æ–°çš„ print å‡½æ•°
def print(text, *args, **kw):
    """
    ä½¿è¾“å‡ºæœ‰åºè¿›è¡Œï¼Œä¸å‡ºç°å¤šçº¿ç¨‹åŒä¸€æ—¶é—´è¾“å‡ºå¯¼è‡´é”™ä¹±çš„é—®é¢˜ã€‚
    """
    with mutex:
        _print(text, *args, **kw)


# é€šçŸ¥æœåŠ¡
# fmt: off
push_config = {
    'HITOKOTO': False,                  # å¯ç”¨ä¸€è¨€ï¼ˆéšæœºå¥å­ï¼‰

    'BARK_PUSH': '',                    # bark IP æˆ–è®¾å¤‡ç ï¼Œä¾‹ï¼šhttps://api.day.app/DxHcxxxxxRxxxxxxcm/
    'BARK_ARCHIVE': '',                 # bark æ¨é€æ˜¯å¦å­˜æ¡£
    'BARK_GROUP': '',                   # bark æ¨é€åˆ†ç»„
    'BARK_SOUND': '',                   # bark æ¨é€å£°éŸ³
    'BARK_ICON': '',                    # bark æ¨é€å›¾æ ‡
    'BARK_LEVEL': '',                   # bark æ¨é€æ—¶æ•ˆæ€§
    'BARK_URL': '',                     # bark æ¨é€è·³è½¬URL

    'CONSOLE': True,                    # æ§åˆ¶å°è¾“å‡º

    'DD_BOT_SECRET': '',                # é’‰é’‰æœºå™¨äººçš„ DD_BOT_SECRET
    'DD_BOT_TOKEN': '',                 # é’‰é’‰æœºå™¨äººçš„ DD_BOT_TOKEN

    'FSKEY': '',                        # é£ä¹¦æœºå™¨äººçš„ FSKEY

    'GOBOT_URL': '',                    # go-cqhttp
                                        # æ¨é€åˆ°ä¸ªäººQQï¼šhttp://127.0.0.1/send_private_msg
                                        # ç¾¤ï¼šhttp://127.0.0.1/send_group_msg
    'GOBOT_QQ': '',                     # go-cqhttp çš„æ¨é€ç¾¤æˆ–ç”¨æˆ·
                                        # GOBOT_URL è®¾ç½® /send_private_msg æ—¶å¡«å…¥ user_id=ä¸ªäººQQ
                                        #               /send_group_msg   æ—¶å¡«å…¥ group_id=QQç¾¤
    'GOBOT_TOKEN': '',                  # go-cqhttp çš„ access_token

    'GOTIFY_URL': '',                   # gotifyåœ°å€,å¦‚https://push.example.de:8080
    'GOTIFY_TOKEN': '',                 # gotifyçš„æ¶ˆæ¯åº”ç”¨token
    'GOTIFY_PRIORITY': 0,               # æ¨é€æ¶ˆæ¯ä¼˜å…ˆçº§,é»˜è®¤ä¸º0

    'IGOT_PUSH_KEY': '',                # iGot èšåˆæ¨é€çš„ IGOT_PUSH_KEY

    'PUSH_KEY': '',                     # server é…±çš„ PUSH_KEYï¼Œå…¼å®¹æ—§ç‰ˆä¸ Turbo ç‰ˆ

    'DEER_KEY': '',                     # PushDeer çš„ PUSHDEER_KEY
    'DEER_URL': '',                     # PushDeer çš„ PUSHDEER_URL

    'CHAT_URL': '',                     # synology chat url
    'CHAT_TOKEN': '',                   # synology chat token

    'PUSH_PLUS_TOKEN': '',              # push+ å¾®ä¿¡æ¨é€çš„ç”¨æˆ·ä»¤ç‰Œ
    'PUSH_PLUS_USER': '',               # push+ å¾®ä¿¡æ¨é€çš„ç¾¤ç»„ç¼–ç 

    'QMSG_KEY': '',                     # qmsg é…±çš„ QMSG_KEY
    'QMSG_TYPE': '',                    # qmsg é…±çš„ QMSG_TYPE

    'QYWX_ORIGIN': '',                  # ä¼ä¸šå¾®ä¿¡ä»£ç†åœ°å€

    'QYWX_AM': '',                      # ä¼ä¸šå¾®ä¿¡åº”ç”¨

    'QYWX_KEY': '',                     # ä¼ä¸šå¾®ä¿¡æœºå™¨äºº

    'TG_BOT_TOKEN': '',                 # tg æœºå™¨äººçš„ TG_BOT_TOKENï¼Œä¾‹ï¼š1407203283:AAG9rt-6RDaaX0HBLZQq0laNOh898iFYaRQ
    'TG_USER_ID': '',                   # tg æœºå™¨äººçš„ TG_USER_IDï¼Œä¾‹ï¼š1434078534
    'TG_API_HOST': '',                  # tg ä»£ç† api
    'TG_PROXY_AUTH': '',                # tg ä»£ç†è®¤è¯å‚æ•°
    'TG_PROXY_HOST': '',                # tg æœºå™¨äººçš„ TG_PROXY_HOST
    'TG_PROXY_PORT': '',                # tg æœºå™¨äººçš„ TG_PROXY_PORT

    'AIBOTK_KEY': '',                   # æ™ºèƒ½å¾®ç§˜ä¹¦ ä¸ªäººä¸­å¿ƒçš„apikey æ–‡æ¡£åœ°å€ï¼šhttp://wechat.aibotk.com/docs/about
    'AIBOTK_TYPE': '',                  # æ™ºèƒ½å¾®ç§˜ä¹¦ å‘é€ç›®æ ‡ room æˆ– contact
    'AIBOTK_NAME': '',                  # æ™ºèƒ½å¾®ç§˜ä¹¦  å‘é€ç¾¤å æˆ–è€…å¥½å‹æ˜µç§°å’Œtypeè¦å¯¹åº”å¥½

    'SMTP_SERVER': '',                  # SMTP å‘é€é‚®ä»¶æœåŠ¡å™¨ï¼Œå½¢å¦‚ smtp.exmail.qq.com:465
    'SMTP_SSL': 'false',                # SMTP å‘é€é‚®ä»¶æœåŠ¡å™¨æ˜¯å¦ä½¿ç”¨ SSLï¼Œå¡«å†™ true æˆ– false
    'SMTP_EMAIL': '',                   # SMTP æ”¶å‘ä»¶é‚®ç®±ï¼Œé€šçŸ¥å°†ä¼šç”±è‡ªå·±å‘ç»™è‡ªå·±
    'SMTP_PASSWORD': '',                # SMTP ç™»å½•å¯†ç ï¼Œä¹Ÿå¯èƒ½ä¸ºç‰¹æ®Šå£ä»¤ï¼Œè§†å…·ä½“é‚®ä»¶æœåŠ¡å•†è¯´æ˜è€Œå®š
    'SMTP_NAME': '',                    # SMTP æ”¶å‘ä»¶äººå§“åï¼Œå¯éšæ„å¡«å†™

    'PUSHME_KEY': '',                   # PushMe é…±çš„ PUSHME_KEY

    'CHRONOCAT_QQ': '',                 # qqå·
    'CHRONOCAT_TOKEN': '',              # CHRONOCAT çš„token
    'CHRONOCAT_URL': '',                # CHRONOCATçš„urlåœ°å€

    'WEBHOOK_URL': '',                  # è‡ªå®šä¹‰é€šçŸ¥ è¯·æ±‚åœ°å€
    'WEBHOOK_BODY': '',                 # è‡ªå®šä¹‰é€šçŸ¥ è¯·æ±‚ä½“
    'WEBHOOK_HEADERS': '',              # è‡ªå®šä¹‰é€šçŸ¥ è¯·æ±‚å¤´
    'WEBHOOK_METHOD': '',               # è‡ªå®šä¹‰é€šçŸ¥ è¯·æ±‚æ–¹æ³•
    'WEBHOOK_CONTENT_TYPE': ''          # è‡ªå®šä¹‰é€šçŸ¥ content-type
}
notify_function = []
# fmt: on

# é¦–å…ˆè¯»å– é¢æ¿å˜é‡ æˆ–è€… github action è¿è¡Œå˜é‡
for k in push_config:
    if os.getenv(k):
        v = os.getenv(k)
        push_config[k] = v


def bark(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ bark æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (push_config.get("BARK_PUSH") or kwargs.get("BARK_PUSH")):
        print("bark æœåŠ¡çš„ BARK_PUSH æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("bark æœåŠ¡å¯åŠ¨")
    BARK_PUSH = kwargs.get("BARK_PUSH", push_config.get("BARK_PUSH"))
    if BARK_PUSH.startswith("http"):
        url = f"{BARK_PUSH}/{urllib.parse.quote_plus(title)}/{urllib.parse.quote_plus(content)}"
    else:
        url = f"https://api.day.app/{BARK_PUSH}/{urllib.parse.quote_plus(title)}/{urllib.parse.quote_plus(content)}"

    bark_params = {
        "BARK_ARCHIVE": "isArchive",
        "BARK_GROUP": "group",
        "BARK_SOUND": "sound",
        "BARK_ICON": "icon",
        "BARK_LEVEL": "level",
        "BARK_URL": "url",
    }
    params = ""
    for pair in filter(
        lambda pairs: pairs[0].startswith("BARK_")
        and pairs[0] != "BARK_PUSH"
        and (pairs[1] or kwargs.get(pairs[0]))
        and bark_params.get(pairs[0]),
        push_config.items(),
    ):
        value = kwargs.get(pair[0], pair[1])
        params += f"{bark_params.get(pair[0])}={value}&"
    if params:
        url = url + "?" + params.rstrip("&")
    response = requests.get(url).json()

    if response["code"] == 200:
        print("bark æ¨é€æˆåŠŸï¼")
    else:
        print("bark æ¨é€å¤±è´¥ï¼")


def console(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ æ§åˆ¶å° æ¨é€æ¶ˆæ¯ã€‚
    """
    print(f"{title}\n\n{content}")


def dingding_bot(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ é’‰é’‰æœºå™¨äºº æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (
        (kwargs.get("DD_BOT_SECRET") and kwargs.get("DD_BOT_TOKEN"))
        or (push_config.get("DD_BOT_SECRET") and push_config.get("DD_BOT_TOKEN"))
    ):
        print("é’‰é’‰æœºå™¨äºº æœåŠ¡çš„ DD_BOT_SECRET æˆ–è€… DD_BOT_TOKEN æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("é’‰é’‰æœºå™¨äºº æœåŠ¡å¯åŠ¨")
    if kwargs.get("DD_BOT_SECRET") and kwargs.get("DD_BOT_TOKEN"):
        DD_BOT_SECRET = kwargs.get("DD_BOT_SECRET")
        DD_BOT_TOKEN = kwargs.get("DD_BOT_TOKEN")
    else:
        DD_BOT_SECRET = push_config.get("DD_BOT_SECRET")
        DD_BOT_TOKEN = push_config.get("DD_BOT_TOKEN")

    timestamp = str(round(time.time() * 1000))
    secret_enc = DD_BOT_SECRET.encode("utf-8")
    string_to_sign = "{}\n{}".format(timestamp, DD_BOT_SECRET)
    string_to_sign_enc = string_to_sign.encode("utf-8")
    hmac_code = hmac.new(
        secret_enc, string_to_sign_enc, digestmod=hashlib.sha256
    ).digest()
    sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))
    url = f"https://oapi.dingtalk.com/robot/send?access_token={DD_BOT_TOKEN}&timestamp={timestamp}&sign={sign}"
    headers = {"Content-Type": "application/json;charset=utf-8"}
    data = {"msgtype": "text", "text": {"content": f"{title}\n\n{content}"}}
    response = requests.post(
        url=url, data=json.dumps(data), headers=headers, timeout=15
    ).json()

    if not response["errcode"]:
        print("é’‰é’‰æœºå™¨äºº æ¨é€æˆåŠŸï¼")
    else:
        print("é’‰é’‰æœºå™¨äºº æ¨é€å¤±è´¥ï¼")


def feishu_bot(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ é£ä¹¦æœºå™¨äºº æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (kwargs.get("DD_BOT_SECRET") or push_config.get("FSKEY")):
        print("é£ä¹¦ æœåŠ¡çš„ FSKEY æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("é£ä¹¦ æœåŠ¡å¯åŠ¨")
    FSKEY = kwargs.get("DD_BOT_SECRET", push_config.get("FSKEY"))
    url = f"https://open.feishu.cn/open-apis/bot/v2/hook/{FSKEY}"
    data = {"msg_type": "text", "content": {"text": f"{title}\n\n{content}"}}
    response = requests.post(url, data=json.dumps(data)).json()

    if response.get("StatusCode") == 0:
        print("é£ä¹¦ æ¨é€æˆåŠŸï¼")
    else:
        print("é£ä¹¦ æ¨é€å¤±è´¥ï¼é”™è¯¯ä¿¡æ¯å¦‚ä¸‹ï¼š\n", response)


def go_cqhttp(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ go_cqhttp æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (
        (kwargs.get("GOBOT_URL") and kwargs.get("GOBOT_QQ"))
        or (push_config.get("GOBOT_URL") and push_config.get("GOBOT_QQ"))
    ):
        print("go-cqhttp æœåŠ¡çš„ GOBOT_URL æˆ– GOBOT_QQ æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("go-cqhttp æœåŠ¡å¯åŠ¨")
    if kwargs.get("GOBOT_URL") and kwargs.get("GOBOT_QQ"):
        GOBOT_URL = kwargs.get("GOBOT_URL")
        GOBOT_QQ = kwargs.get("GOBOT_QQ")
        GOBOT_TOKEN = kwargs.get("GOBOT_TOKEN")
    else:
        GOBOT_URL = push_config.get("GOBOT_URL")
        GOBOT_QQ = push_config.get("GOBOT_QQ")
        GOBOT_TOKEN = push_config.get("GOBOT_TOKEN")

    url = f"{GOBOT_URL}?access_token={GOBOT_TOKEN}&{GOBOT_QQ}&message=æ ‡é¢˜:{title}\nå†…å®¹:{content}"
    response = requests.get(url).json()

    if response["status"] == "ok":
        print("go-cqhttp æ¨é€æˆåŠŸï¼")
    else:
        print("go-cqhttp æ¨é€å¤±è´¥ï¼")


def gotify(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ gotify æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (
        (kwargs.get("GOTIFY_URL") and kwargs.get("GOTIFY_TOKEN"))
        or (push_config.get("GOTIFY_URL") and push_config.get("GOTIFY_TOKEN"))
    ):
        print("gotify æœåŠ¡çš„ GOTIFY_URL æˆ– GOTIFY_TOKEN æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("gotify æœåŠ¡å¯åŠ¨")
    if kwargs.get("GOTIFY_URL") and kwargs.get("GOTIFY_TOKEN"):
        GOTIFY_URL = kwargs.get("GOTIFY_URL")
        GOTIFY_TOKEN = kwargs.get("GOBOTGOTIFY_TOKEN_QQ")
        GOTIFY_PRIORITY = kwargs.get("GOTIFY_PRIORITY")
    else:
        GOTIFY_URL = push_config.get("GOTIFY_URL")
        GOTIFY_TOKEN = push_config.get("GOTIFY_TOKEN")
        GOTIFY_PRIORITY = kwargs.get("GOTIFY_PRIORITY")

    url = f"{GOTIFY_URL}/message?token={GOTIFY_TOKEN}"
    data = {
        "title": title,
        "message": content,
        "priority": GOTIFY_PRIORITY,
    }
    response = requests.post(url, data=data).json()

    if response.get("id"):
        print("gotify æ¨é€æˆåŠŸï¼")
    else:
        print("gotify æ¨é€å¤±è´¥ï¼")


def iGot(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ iGot æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (kwargs.get("IGOT_PUSH_KEY") or push_config.get("IGOT_PUSH_KEY")):
        print("iGot æœåŠ¡çš„ IGOT_PUSH_KEY æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("iGot æœåŠ¡å¯åŠ¨")
    IGOT_PUSH_KEY = kwargs.get("IGOT_PUSH_KEY", push_config.get("IGOT_PUSH_KEY"))
    url = f"https://push.hellyw.com/{IGOT_PUSH_KEY}"
    data = {"title": title, "content": content}
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    response = requests.post(url, data=data, headers=headers).json()

    if response["ret"] == 0:
        print("iGot æ¨é€æˆåŠŸï¼")
    else:
        print(f'iGot æ¨é€å¤±è´¥ï¼{response["errMsg"]}')


def serverJ(title: str, content: str, **kwargs) -> None:
    """
    é€šè¿‡ serverJ æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (kwargs.get("PUSH_KEY") or push_config.get("PUSH_KEY")):
        print("serverJ æœåŠ¡çš„ PUSH_KEY æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("serverJ æœåŠ¡å¯åŠ¨")
    PUSH_KEY = kwargs.get("PUSH_KEY", push_config.get("PUSH_KEY"))

    data = {"text": title, "desp": content.replace("\n", "\n\n")}
    if PUSH_KEY.find("SCT") != -1:
        url = f"https://sctapi.ftqq.com/{PUSH_KEY}.send"
    else:
        url = f"https://sc.ftqq.com/{PUSH_KEY}.send"
    response = requests.post(url, data=data).json()

    if response.get("errno") == 0 or response.get("code") == 0:
        print("serverJ æ¨é€æˆåŠŸï¼")
    else:
        print(f'serverJ æ¨é€å¤±è´¥ï¼é”™è¯¯ç ï¼š{response["message"]}')


def pushdeer(title: str, content: str, **kwargs) -> None:
    """
    é€šè¿‡PushDeer æ¨é€æ¶ˆæ¯
    """
    if not (kwargs.get("DEER_KEY") or push_config.get("DEER_KEY")):
        print("PushDeer æœåŠ¡çš„ DEER_KEY æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("PushDeer æœåŠ¡å¯åŠ¨")
    DEER_KEY = kwargs.get("DEER_KEY", push_config.get("DEER_KEY"))

    data = {
        "text": title,
        "desp": content,
        "type": "markdown",
        "pushkey": DEER_KEY,
    }
    url = "https://api2.pushdeer.com/message/push"
    if push_config.get("DEER_URL"):
        url = push_config.get("DEER_URL")
    if kwargs.get("DEER_URL"):
        url = kwargs.get("DEER_URL")

    response = requests.post(url, data=data).json()

    if len(response.get("content").get("result")) > 0:
        print("PushDeer æ¨é€æˆåŠŸï¼")
    else:
        print("PushDeer æ¨é€å¤±è´¥ï¼é”™è¯¯ä¿¡æ¯ï¼š", response)


def chat(title: str, content: str, **kwargs) -> None:
    """
    é€šè¿‡Chat æ¨é€æ¶ˆæ¯
    """
    if not (
        (kwargs.get("CHAT_URL") and kwargs.get("CHAT_TOKEN"))
        or (push_config.get("CHAT_URL") and push_config.get("CHAT_TOKEN"))
    ):
        print("chat æœåŠ¡çš„ CHAT_URLæˆ–CHAT_TOKEN æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("chat æœåŠ¡å¯åŠ¨")
    if kwargs.get("CHAT_URL") and kwargs.get("CHAT_TOKEN"):
        CHAT_URL = kwargs.get("CHAT_URL")
        CHAT_TOKEN = kwargs.get("CHAT_TOKEN")
    else:
        CHAT_URL = push_config.get("CHAT_URL")
        CHAT_TOKEN = push_config.get("CHAT_TOKEN")

    data = "payload=" + json.dumps({"text": title + "\n" + content})
    url = CHAT_URL + CHAT_TOKEN
    response = requests.post(url, data=data)

    if response.status_code == 200:
        print("Chat æ¨é€æˆåŠŸï¼")
    else:
        print("Chat æ¨é€å¤±è´¥ï¼é”™è¯¯ä¿¡æ¯ï¼š", response)


def pushplus_bot(title: str, content: str, **kwargs) -> None:
    """
    é€šè¿‡ push+ æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (kwargs.get("PUSH_PLUS_TOKEN") or push_config.get("PUSH_PLUS_TOKEN")):
        print("PUSHPLUS æœåŠ¡çš„ PUSH_PLUS_TOKEN æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("PUSHPLUS æœåŠ¡å¯åŠ¨")
    PUSH_PLUS_TOKEN = kwargs.get("PUSH_PLUS_TOKEN", push_config.get("PUSH_PLUS_TOKEN"))
    PUSH_PLUS_USER = kwargs.get("PUSH_PLUS_USER", push_config.get("PUSH_PLUS_USER"))

    url = "http://www.pushplus.plus/send"
    data = {
        "token": PUSH_PLUS_TOKEN,
        "title": title,
        "content": content,
        "topic": PUSH_PLUS_USER,
    }
    body = json.dumps(data).encode(encoding="utf-8")
    headers = {"Content-Type": "application/json"}
    response = requests.post(url=url, data=body, headers=headers).json()

    if response["code"] == 200:
        print("PUSHPLUS æ¨é€æˆåŠŸï¼")

    else:
        url_old = "http://pushplus.hxtrip.com/send"
        headers["Accept"] = "application/json"
        response = requests.post(url=url_old, data=body, headers=headers).json()

        if response["code"] == 200:
            print("PUSHPLUS(hxtrip) æ¨é€æˆåŠŸï¼")

        else:
            print("PUSHPLUS æ¨é€å¤±è´¥ï¼")


def qmsg_bot(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ qmsg æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (
        (kwargs.get("QMSG_KEY") and kwargs.get("QMSG_TYPE"))
        or (push_config.get("QMSG_KEY") and push_config.get("QMSG_TYPE"))
    ):
        print("qmsg çš„ QMSG_KEY æˆ–è€… QMSG_TYPE æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("qmsg æœåŠ¡å¯åŠ¨")
    if kwargs.get("QMSG_KEY") and kwargs.get("QMSG_TYPE"):
        QMSG_KEY = kwargs.get("QMSG_KEY")
        QMSG_TYPE = kwargs.get("QMSG_TYPE")
    else:
        QMSG_KEY = push_config.get("QMSG_KEY")
        QMSG_TYPE = push_config.get("QMSG_TYPE")

    url = f"https://qmsg.zendee.cn/{QMSG_TYPE}/{QMSG_KEY}"
    payload = {"msg": f'{title}\n\n{content.replace("----", "-")}'.encode("utf-8")}
    response = requests.post(url=url, params=payload).json()

    if response["code"] == 0:
        print("qmsg æ¨é€æˆåŠŸï¼")
    else:
        print(f'qmsg æ¨é€å¤±è´¥ï¼{response["reason"]}')


def wecom_app(title: str, content: str, **kwargs) -> None:
    """
    é€šè¿‡ ä¼ä¸šå¾®ä¿¡ APP æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (kwargs.get("QYWX_AM") or push_config.get("QYWX_AM")):
        print("QYWX_AM æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    QYWX_AM = kwargs.get("QYWX_AM", push_config.get("QYWX_AM"))
    QYWX_AM_AY = re.split(",", QYWX_AM)
    if 4 < len(QYWX_AM_AY) > 5:
        print("QYWX_AM è®¾ç½®é”™è¯¯!!\nå–æ¶ˆæ¨é€")
        return
    print("ä¼ä¸šå¾®ä¿¡ APP æœåŠ¡å¯åŠ¨")

    corpid = QYWX_AM_AY[0]
    corpsecret = QYWX_AM_AY[1]
    touser = QYWX_AM_AY[2]
    agentid = QYWX_AM_AY[3]
    try:
        media_id = QYWX_AM_AY[4]
    except IndexError:
        media_id = ""
    wx = WeCom(corpid, corpsecret, agentid)
    # å¦‚æœæ²¡æœ‰é…ç½® media_id é»˜è®¤å°±ä»¥ text æ–¹å¼å‘é€
    if not media_id:
        message = title + "\n\n" + content
        response = wx.send_text(message, touser)
    else:
        response = wx.send_mpnews(title, content, media_id, touser)

    if response == "ok":
        print("ä¼ä¸šå¾®ä¿¡æ¨é€æˆåŠŸï¼")
    else:
        print("ä¼ä¸šå¾®ä¿¡æ¨é€å¤±è´¥ï¼é”™è¯¯ä¿¡æ¯å¦‚ä¸‹ï¼š\n", response)


class WeCom:
    def __init__(self, corpid, corpsecret, agentid):
        self.CORPID = corpid
        self.CORPSECRET = corpsecret
        self.AGENTID = agentid
        self.ORIGIN = "https://qyapi.weixin.qq.com"
        if push_config.get("QYWX_ORIGIN"):
            self.ORIGIN = push_config.get("QYWX_ORIGIN")

    def get_access_token(self):
        url = f"{self.ORIGIN}/cgi-bin/gettoken"
        values = {
            "corpid": self.CORPID,
            "corpsecret": self.CORPSECRET,
        }
        req = requests.post(url, params=values)
        data = json.loads(req.text)
        return data["access_token"]

    def send_text(self, message, touser="@all"):
        send_url = (
            f"{self.ORIGIN}/cgi-bin/message/send?access_token={self.get_access_token()}"
        )
        send_values = {
            "touser": touser,
            "msgtype": "text",
            "agentid": self.AGENTID,
            "text": {"content": message},
            "safe": "0",
        }
        send_msges = bytes(json.dumps(send_values), "utf-8")
        respone = requests.post(send_url, send_msges)
        respone = respone.json()
        return respone["errmsg"]

    def send_mpnews(self, title, message, media_id, touser="@all"):
        send_url = (
            f"{self.ORIGIN}/cgi-bin/message/send?access_token={self.get_access_token()}"
        )
        send_values = {
            "touser": touser,
            "msgtype": "mpnews",
            "agentid": self.AGENTID,
            "mpnews": {
                "articles": [
                    {
                        "title": title,
                        "thumb_media_id": media_id,
                        "author": "Author",
                        "content_source_url": "",
                        "content": message.replace("\n", "<br/>"),
                        "digest": message,
                    }
                ]
            },
        }
        send_msges = bytes(json.dumps(send_values), "utf-8")
        respone = requests.post(send_url, send_msges)
        respone = respone.json()
        return respone["errmsg"]


def wecom_bot(title: str, content: str, **kwargs) -> None:
    """
    é€šè¿‡ ä¼ä¸šå¾®ä¿¡æœºå™¨äºº æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (kwargs.get("QYWX_KEY") or push_config.get("QYWX_KEY")):
        print("ä¼ä¸šå¾®ä¿¡æœºå™¨äºº æœåŠ¡çš„ QYWX_KEY æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("ä¼ä¸šå¾®ä¿¡æœºå™¨äººæœåŠ¡å¯åŠ¨")
    QYWX_KEY = kwargs.get("QYWX_KEY", push_config.get("QYWX_KEY"))

    origin = "https://qyapi.weixin.qq.com"
    if push_config.get("QYWX_ORIGIN"):
        origin = push_config.get("QYWX_ORIGIN")
    if kwargs.get("QYWX_ORIGIN"):
        origin = kwargs.get("QYWX_ORIGIN")

    url = f"{origin}/cgi-bin/webhook/send?key={QYWX_KEY}"
    headers = {"Content-Type": "application/json;charset=utf-8"}
    data = {"msgtype": "text", "text": {"content": f"{title}\n\n{content}"}}
    response = requests.post(
        url=url, data=json.dumps(data), headers=headers, timeout=15
    ).json()

    if response["errcode"] == 0:
        print("ä¼ä¸šå¾®ä¿¡æœºå™¨äººæ¨é€æˆåŠŸï¼")
    else:
        print("ä¼ä¸šå¾®ä¿¡æœºå™¨äººæ¨é€å¤±è´¥ï¼")


def telegram_bot(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ telegram æœºå™¨äºº æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (
        (kwargs.get("TG_BOT_TOKEN") and kwargs.get("TG_USER_ID"))
        or (push_config.get("TG_BOT_TOKEN") and push_config.get("TG_USER_ID"))
    ):
        print("tg æœåŠ¡çš„ TG_BOT_TOKEN æˆ–è€… TG_USER_ID æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("tg æœåŠ¡å¯åŠ¨")
    if kwargs.get("TG_BOT_TOKEN") and kwargs.get("TG_USER_ID"):
        TG_BOT_TOKEN = kwargs.get("TG_BOT_TOKEN")
        TG_USER_ID = kwargs.get("TG_USER_ID")
    else:
        TG_BOT_TOKEN = push_config.get("TG_BOT_TOKEN")
        TG_USER_ID = push_config.get("TG_USER_ID")

    if kwargs.get("TG_API_HOST") or push_config.get("TG_API_HOST"):
        TG_API_HOST = kwargs.get("TG_API_HOST", push_config.get("TG_API_HOST"))
        url = f"{TG_API_HOST}/bot{TG_BOT_TOKEN}/sendMessage"
    else:
        url = f"https://api.telegram.org/bot{TG_BOT_TOKEN}/sendMessage"
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    payload = {
        "chat_id": str(TG_USER_ID),
        "text": f"{title}\n\n{content}",
        "disable_web_page_preview": "true",
    }
    proxies = None
    if not (
        (kwargs.get("TG_PROXY_HOST") and kwargs.get("TG_PROXY_PORT"))
        or (push_config.get("TG_PROXY_HOST") and push_config.get("TG_PROXY_PORT"))
    ):
        if kwargs.get("TG_PROXY_HOST") and kwargs.get("TG_PROXY_PORT"):
            TG_PROXY_HOST = kwargs.get("TG_PROXY_HOST")
            TG_PROXY_PORT = kwargs.get("TG_PROXY_PORT")
        else:
            TG_PROXY_HOST = kwargs.get("TG_PROXY_HOST")
            TG_PROXY_PORT = kwargs.get("TG_PROXY_PORT")
        if kwargs.get("TG_PROXY_AUTH") or push_config.get("TG_PROXY_AUTH"):
            TG_PROXY_AUTH = kwargs.get(
                "TG_PROXY_AUTH", push_config.get("TG_PROXY_AUTH")
            )
        if TG_PROXY_AUTH is not None and "@" not in TG_PROXY_HOST:
            TG_PROXY_HOST = TG_PROXY_AUTH + "@" + TG_PROXY_HOST
        proxyStr = "http://{}:{}".format(TG_PROXY_HOST, TG_PROXY_PORT)
        proxies = {"http": proxyStr, "https": proxyStr}
    response = requests.post(
        url=url, headers=headers, params=payload, proxies=proxies
    ).json()

    if response["ok"]:
        print("tg æ¨é€æˆåŠŸï¼")
    else:
        print("tg æ¨é€å¤±è´¥ï¼")


def aibotk(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ æ™ºèƒ½å¾®ç§˜ä¹¦ æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (
        (
            kwargs.get("AIBOTK_KEY")
            and kwargs.get("AIBOTK_TYPE")
            and kwargs.get("AIBOTK_NAME")
        )
        or (
            push_config.get("AIBOTK_KEY")
            and push_config.get("AIBOTK_TYPE")
            and push_config.get("AIBOTK_NAME")
        )
    ):
        print(
            "æ™ºèƒ½å¾®ç§˜ä¹¦ çš„ AIBOTK_KEY æˆ–è€… AIBOTK_TYPE æˆ–è€… AIBOTK_NAME æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€"
        )
        return
    print("æ™ºèƒ½å¾®ç§˜ä¹¦ æœåŠ¡å¯åŠ¨")
    if (
        kwargs.get("AIBOTK_KEY")
        and kwargs.get("AIBOTK_TYPE")
        and kwargs.get("AIBOTK_NAME")
    ):
        AIBOTK_KEY = kwargs.get("AIBOTK_KEY")
        AIBOTK_TYPE = kwargs.get("AIBOTK_TYPE")
        AIBOTK_NAME = kwargs.get("AIBOTK_NAME")
    else:
        AIBOTK_KEY = push_config.get("AIBOTK_KEY")
        AIBOTK_TYPE = push_config.get("AIBOTK_TYPE")
        AIBOTK_NAME = push_config.get("AIBOTK_NAME")
    if AIBOTK_TYPE == "room":
        url = "https://api-bot.aibotk.com/openapi/v1/chat/room"
        data = {
            "apiKey": AIBOTK_KEY,
            "roomName": AIBOTK_NAME,
            "message": {"type": 1, "content": f"ã€é’é¾™å¿«è®¯ã€‘\n\n{title}\n{content}"},
        }
    else:
        url = "https://api-bot.aibotk.com/openapi/v1/chat/contact"
        data = {
            "apiKey": AIBOTK_KEY,
            "name": AIBOTK_NAME,
            "message": {"type": 1, "content": f"ã€é’é¾™å¿«è®¯ã€‘\n\n{title}\n{content}"},
        }
    body = json.dumps(data).encode(encoding="utf-8")
    headers = {"Content-Type": "application/json"}
    response = requests.post(url=url, data=body, headers=headers).json()
    print(response)
    if response["code"] == 0:
        print("æ™ºèƒ½å¾®ç§˜ä¹¦ æ¨é€æˆåŠŸï¼")
    else:
        print(f'æ™ºèƒ½å¾®ç§˜ä¹¦ æ¨é€å¤±è´¥ï¼{response["error"]}')


def smtp(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ SMTP é‚®ä»¶ æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (
        (
            kwargs.get("SMTP_SERVER")
            and kwargs.get("SMTP_SSL")
            and kwargs.get("SMTP_EMAIL")
            and kwargs.get("SMTP_PASSWORD")
            and kwargs.get("SMTP_NAME")
        )
        or (
            push_config.get("SMTP_SERVER")
            and push_config.get("SMTP_SSL")
            and push_config.get("SMTP_EMAIL")
            and push_config.get("SMTP_PASSWORD")
            and push_config.get("SMTP_NAME")
        )
    ):
        print(
            "SMTP é‚®ä»¶ çš„ SMTP_SERVER æˆ–è€… SMTP_SSL æˆ–è€… SMTP_EMAIL æˆ–è€… SMTP_PASSWORD æˆ–è€… SMTP_NAME æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€"
        )
        return
    print("SMTP é‚®ä»¶ æœåŠ¡å¯åŠ¨")
    if (
        kwargs.get("SMTP_SERVER")
        and kwargs.get("SMTP_SSL")
        and kwargs.get("SMTP_EMAIL")
        and kwargs.get("SMTP_PASSWORD")
        and kwargs.get("SMTP_NAME")
    ):
        SMTP_SERVER = kwargs.get("SMTP_SERVER")
        SMTP_SSL = kwargs.get("SMTP_SSL")
        SMTP_EMAIL = kwargs.get("SMTP_EMAIL")
        SMTP_PASSWORD = kwargs.get("SMTP_PASSWORD")
        SMTP_NAME = kwargs.get("SMTP_NAME")
    else:
        SMTP_SERVER = push_config.get("SMTP_SERVER")
        SMTP_SSL = push_config.get("SMTP_SSL")
        SMTP_EMAIL = push_config.get("SMTP_EMAIL")
        SMTP_PASSWORD = push_config.get("SMTP_PASSWORD")
        SMTP_NAME = push_config.get("SMTP_NAME")

    message = MIMEText(content, "plain", "utf-8")
    message["From"] = formataddr(
        (
            Header(SMTP_NAME, "utf-8").encode(),
            SMTP_EMAIL,
        )
    )
    message["To"] = formataddr(
        (
            Header(SMTP_NAME, "utf-8").encode(),
            SMTP_EMAIL,
        )
    )
    message["Subject"] = Header(title, "utf-8")

    try:
        smtp_server = (
            smtplib.SMTP_SSL(SMTP_SERVER)
            if SMTP_SSL == "true"
            else smtplib.SMTP(SMTP_SERVER)
        )
        smtp_server.login(SMTP_EMAIL, SMTP_PASSWORD)
        smtp_server.sendmail(
            SMTP_EMAIL,
            SMTP_EMAIL,
            message.as_bytes(),
        )
        smtp_server.close()
        print("SMTP é‚®ä»¶ æ¨é€æˆåŠŸï¼")
    except Exception as e:
        print(f"SMTP é‚®ä»¶ æ¨é€å¤±è´¥ï¼{e}")


def pushme(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ PushMe æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (kwargs.get("PUSHME_KEY") or push_config.get("PUSHME_KEY")):
        print("PushMe æœåŠ¡çš„ PUSHME_KEY æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("PushMe æœåŠ¡å¯åŠ¨")
    PUSHME_KEY = kwargs.get("PUSHME_KEY", push_config.get("PUSHME_KEY"))

    url = f"https://push.i-i.me/?push_key={PUSHME_KEY}"
    data = {
        "title": title,
        "content": content,
    }
    response = requests.post(url, data=data)

    if response.status_code == 200 and response.text == "success":
        print("PushMe æ¨é€æˆåŠŸï¼")
    else:
        print(f"PushMe æ¨é€å¤±è´¥ï¼{response.status_code} {response.text}")


def chronocat(title: str, content: str, **kwargs) -> None:
    """
    ä½¿ç”¨ CHRONOCAT æ¨é€æ¶ˆæ¯ã€‚
    """
    if not (
        (
            push_config.get("CHRONOCAT_URL")
            and push_config.get("CHRONOCAT_QQ")
            and push_config.get("CHRONOCAT_TOKEN")
        )
        or (
            push_config.get("CHRONOCAT_URL")
            and push_config.get("CHRONOCAT_QQ")
            and push_config.get("CHRONOCAT_TOKEN")
        )
    ):
        print("CHRONOCAT æœåŠ¡çš„ CHRONOCAT_URL æˆ– CHRONOCAT_QQ æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("CHRONOCAT æœåŠ¡å¯åŠ¨")
    if (
        kwargs.get("CHRONOCAT_URL")
        and kwargs.get("CHRONOCAT_QQ")
        and kwargs.get("CHRONOCAT_TOKEN")
    ):
        CHRONOCAT_URL = kwargs.get("CHRONOCAT_URL")
        CHRONOCAT_QQ = kwargs.get("CHRONOCAT_QQ")
        CHRONOCAT_TOKEN = kwargs.get("CHRONOCAT_TOKEN")
    else:
        CHRONOCAT_URL = push_config.get("CHRONOCAT_URL")
        CHRONOCAT_QQ = push_config.get("CHRONOCAT_QQ")
        CHRONOCAT_TOKEN = push_config.get("CHRONOCAT_TOKEN")

    user_ids = re.findall(r"user_id=(\d+)", CHRONOCAT_QQ)
    group_ids = re.findall(r"group_id=(\d+)", CHRONOCAT_QQ)

    url = f"{CHRONOCAT_URL}/api/message/send"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {CHRONOCAT_TOKEN}",
    }

    for chat_type, ids in [(1, user_ids), (2, group_ids)]:
        if not ids:
            continue
        for chat_id in ids:
            data = {
                "peer": {"chatType": chat_type, "peerUin": chat_id},
                "elements": [
                    {
                        "elementType": 1,
                        "textElement": {"content": f"{title}\n\n{content}"},
                    }
                ],
            }
            response = requests.post(url, headers=headers, data=json.dumps(data))
            if response.status_code == 200:
                if chat_type == 1:
                    print(f"QQä¸ªäººæ¶ˆæ¯:{ids}æ¨é€æˆåŠŸï¼")
                else:
                    print(f"QQç¾¤æ¶ˆæ¯:{ids}æ¨é€æˆåŠŸï¼")
            else:
                if chat_type == 1:
                    print(f"QQä¸ªäººæ¶ˆæ¯:{ids}æ¨é€å¤±è´¥ï¼")
                else:
                    print(f"QQç¾¤æ¶ˆæ¯:{ids}æ¨é€å¤±è´¥ï¼")


def parse_headers(headers):
    if not headers:
        return {}

    parsed = {}
    lines = headers.split("\n")

    for line in lines:
        i = line.find(":")
        if i == -1:
            continue

        key = line[:i].strip().lower()
        val = line[i + 1 :].strip()
        parsed[key] = parsed.get(key, "") + ", " + val if key in parsed else val

    return parsed


def parse_string(input_string, value_format_fn=None):
    matches = {}
    pattern = r"(\w+):\s*((?:(?!\n\w+:).)*)"
    regex = re.compile(pattern)
    for match in regex.finditer(input_string):
        key, value = match.group(1).strip(), match.group(2).strip()
        try:
            value = value_format_fn(value) if value_format_fn else value
            json_value = json.loads(value)
            matches[key] = json_value
        except:
            matches[key] = value
    return matches


def parse_body(body, content_type, value_format_fn=None):
    if not body or content_type == "text/plain":
        return body

    parsed = parse_string(input_string, value_format_fn)

    if content_type == "application/x-www-form-urlencoded":
        data = urlencode(parsed, doseq=True)
        return data

    if content_type == "application/json":
        data = json.dumps(parsed)
        return data

    return parsed


def format_notify_content(url, body, title, content):
    if "$title" not in url and "$title" not in body:
        return {}

    formatted_url = url.replace("$title", urllib.parse.quote_plus(title)).replace(
        "$content", urllib.parse.quote_plus(content)
    )
    formatted_body = body.replace("$title", title).replace("$content", content)

    return formatted_url, formatted_body


def webhook_notify(title: str, content: str) -> None:
    """
    é€šè¿‡ WEBHOOK æ¨é€æ¶ˆæ¯ã€‚
    """
    if not push_config.get("WEBHOOK_URL"):
        print("WEBHOOK æœåŠ¡çš„ WEBHOOK_URL æœªè®¾ç½®!!\nå–æ¶ˆæ¨é€")
        return
    print("WEBHOOKæœåŠ¡å¯åŠ¨")

    url = f"{push_config.get('WEBHOOK_URL')}"
    headers = {"Content-Type": "application/json;charset=utf-8"}
    data = {"title": f"{title}", "content": f"{content}"}
    response = requests.post(
        url=url, data=json.dumps(data), headers=headers, timeout=15
    ).json()

    print("WEBHOOK æ¨é€æˆåŠŸï¼")

def one() -> str:
    """
    è·å–ä¸€æ¡ä¸€è¨€ã€‚
    :return:
    """
    url = "https://v1.hitokoto.cn/"
    res = requests.get(url).json()
    return res["hitokoto"] + "    ----" + res["from"]


def add_notify_function():
    if push_config.get("BARK_PUSH"):
        notify_function.append(bark)
    if push_config.get("CONSOLE"):
        notify_function.append(console)
    if push_config.get("DD_BOT_TOKEN") and push_config.get("DD_BOT_SECRET"):
        notify_function.append(dingding_bot)
    if push_config.get("FSKEY"):
        notify_function.append(feishu_bot)
    if push_config.get("GOBOT_URL") and push_config.get("GOBOT_QQ"):
        notify_function.append(go_cqhttp)
    if push_config.get("GOTIFY_URL") and push_config.get("GOTIFY_TOKEN"):
        notify_function.append(gotify)
    if push_config.get("IGOT_PUSH_KEY"):
        notify_function.append(iGot)
    if push_config.get("PUSH_KEY"):
        notify_function.append(serverJ)
    if push_config.get("DEER_KEY"):
        notify_function.append(pushdeer)
    if push_config.get("CHAT_URL") and push_config.get("CHAT_TOKEN"):
        notify_function.append(chat)
    if push_config.get("PUSH_PLUS_TOKEN"):
        notify_function.append(pushplus_bot)
    if push_config.get("QMSG_KEY") and push_config.get("QMSG_TYPE"):
        notify_function.append(qmsg_bot)
    if push_config.get("QYWX_AM"):
        notify_function.append(wecom_app)
    if push_config.get("QYWX_KEY"):
        notify_function.append(wecom_bot)
    if push_config.get("TG_BOT_TOKEN") and push_config.get("TG_USER_ID"):
        notify_function.append(telegram_bot)
    if (
        push_config.get("AIBOTK_KEY")
        and push_config.get("AIBOTK_TYPE")
        and push_config.get("AIBOTK_NAME")
    ):
        notify_function.append(aibotk)
    if (
        push_config.get("SMTP_SERVER")
        and push_config.get("SMTP_SSL")
        and push_config.get("SMTP_EMAIL")
        and push_config.get("SMTP_PASSWORD")
        and push_config.get("SMTP_NAME")
    ):
        notify_function.append(smtp)
    if push_config.get("PUSHME_KEY"):
        notify_function.append(pushme)
    if (
        push_config.get("CHRONOCAT_URL")
        and push_config.get("CHRONOCAT_QQ")
        and push_config.get("CHRONOCAT_TOKEN")
    ):
        notify_function.append(chronocat)
    if push_config.get("WEBHOOK_URL") and push_config.get("WEBHOOK_METHOD"):
        notify_function.append(custom_notify)


def send(title: str, content: str, **kwargs) -> None:
    if not content:
        print(f"{title} æ¨é€å†…å®¹ä¸ºç©ºï¼")
        return

    # æ ¹æ®æ ‡é¢˜è·³è¿‡ä¸€äº›æ¶ˆæ¯æ¨é€ï¼Œç¯å¢ƒå˜é‡ï¼šSKIP_PUSH_TITLE ç”¨å›è½¦åˆ†éš”
    skipTitle = os.getenv("SKIP_PUSH_TITLE")
    if skipTitle:
        if title in re.split("\n", skipTitle):
            print(f"{title} åœ¨SKIP_PUSH_TITLEç¯å¢ƒå˜é‡å†…ï¼Œè·³è¿‡æ¨é€ï¼")
            return

    hitokoto = push_config.get("HITOKOTO")
    content += "\n\n" + one() if hitokoto else ""

    add_notify_function()
    ts = [
        threading.Thread(
            target=mode, args=(title, content), kwargs=kwargs, name=mode.__name__
        )
        for mode in notify_function
    ]
    [t.start() for t in ts]
    [t.join() for t in ts]


def main():
    send("title", "content")


if __name__ == "__main__":
    main()
~~~

### sendNotify.jsæ–‡ä»¶å†…å®¹
~~~js
/*
 * @Author: lxk0301 https://gitee.com/lxk0301
 * @Date: 2020-08-19 16:12:40
 * @Last Modified by: whyour
 * @Last Modified time: 2021-5-1 15:00:54
 * sendNotify æ¨é€é€šçŸ¥åŠŸèƒ½
 * @param text é€šçŸ¥å¤´
 * @param desp é€šçŸ¥ä½“
 * @param params æŸäº›æ¨é€é€šçŸ¥æ–¹å¼ç‚¹å‡»å¼¹çª—å¯è·³è½¬, ä¾‹ï¼š{ url: 'https://abc.com' }
 * @param author ä½œè€…ä»“åº“ç­‰ä¿¡æ¯  ä¾‹ï¼š`æœ¬é€šçŸ¥ Byï¼šhttps://github.com/whyour/qinglong`
 */

const querystring = require('querystring');
const got = require('got');
const $ = new Env();
const timeout = 15000; // è¶…æ—¶æ—¶é—´(å•ä½æ¯«ç§’)
// =======================================gotifyé€šçŸ¥è®¾ç½®åŒºåŸŸ==============================================
// gotify_url å¡«å†™gotifyåœ°å€,å¦‚https://push.example.de:8080
// gotify_token å¡«å†™gotifyçš„æ¶ˆæ¯åº”ç”¨token
// gotify_priority å¡«å†™æ¨é€æ¶ˆæ¯ä¼˜å…ˆçº§,é»˜è®¤ä¸º0
let GOTIFY_URL = '';
let GOTIFY_TOKEN = '';
let GOTIFY_PRIORITY = 0;
// =======================================go-cqhttpé€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
// gobot_url å¡«å†™è¯·æ±‚åœ°å€http://127.0.0.1/send_private_msg
// gobot_token å¡«å†™åœ¨go-cqhttpæ–‡ä»¶è®¾ç½®çš„è®¿é—®å¯†é’¥
// gobot_qq å¡«å†™æ¨é€åˆ°ä¸ªäººQQæˆ–è€…QQç¾¤å·
// go-cqhttpç›¸å…³API https://docs.go-cqhttp.org/api
let GOBOT_URL = ''; // æ¨é€åˆ°ä¸ªäººQQ: http://127.0.0.1/send_private_msg  ç¾¤ï¼šhttp://127.0.0.1/send_group_msg
let GOBOT_TOKEN = ''; // è®¿é—®å¯†é’¥
let GOBOT_QQ = ''; // å¦‚æœGOBOT_URLè®¾ç½® /send_private_msg åˆ™éœ€è¦å¡«å…¥ user_id=ä¸ªäººQQ ç›¸åå¦‚æœæ˜¯ /send_group_msg åˆ™éœ€è¦å¡«å…¥ group_id=QQç¾¤

// =======================================å¾®ä¿¡serveré…±é€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
// æ­¤å¤„å¡«ä½ ç”³è¯·çš„SCKEY.
// (ç¯å¢ƒå˜é‡å PUSH_KEY)
let SCKEY = '';

// =======================================PushDeeré€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
// æ­¤å¤„å¡«ä½ ç”³è¯·çš„PushDeer KEY.
// (ç¯å¢ƒå˜é‡å DEER_KEY)
let PUSHDEER_KEY = '';
let PUSHDEER_URL = '';

// =======================================Synology Chaté€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
// æ­¤å¤„å¡«ä½ ç”³è¯·çš„CHAT_URLä¸CHAT_TOKEN
// (ç¯å¢ƒå˜é‡å CHAT_URL CHAT_TOKEN)
let CHAT_URL = '';
let CHAT_TOKEN = '';

// =======================================Bark Appé€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
// æ­¤å¤„å¡«ä½ BarkAPPçš„ä¿¡æ¯(IP/è®¾å¤‡ç ï¼Œä¾‹å¦‚ï¼šhttps://api.day.app/XXXXXXXX)
let BARK_PUSH = '';
// BARK appæ¨é€å›¾æ ‡,è‡ªå®šä¹‰æ¨é€å›¾æ ‡(éœ€iOS15æˆ–ä»¥ä¸Š)
let BARK_ICON = 'https://qn.whyour.cn/logo.png';
// BARK appæ¨é€é“ƒå£°,é“ƒå£°åˆ—è¡¨å»APPæŸ¥çœ‹å¤åˆ¶å¡«å†™
let BARK_SOUND = '';
// BARK appæ¨é€æ¶ˆæ¯çš„åˆ†ç»„, é»˜è®¤ä¸º"QingLong"
let BARK_GROUP = 'QingLong';
// BARK appæ¨é€æ¶ˆæ¯çš„æ—¶æ•ˆæ€§, é»˜è®¤ä¸º"active"
let BARK_LEVEL = 'active';
// BARK appæ¨é€æ¶ˆæ¯çš„è·³è½¬URL
let BARK_URL = '';

// =======================================telegramæœºå™¨äººé€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
// æ­¤å¤„å¡«ä½ telegram bot çš„Tokenï¼Œtelegramæœºå™¨äººé€šçŸ¥æ¨é€å¿…å¡«é¡¹.ä¾‹å¦‚ï¼š1077xxx4424:AAFjv0FcqxxxxxxgEMGfi22B4yh15R5uw
// (ç¯å¢ƒå˜é‡å TG_BOT_TOKEN)
let TG_BOT_TOKEN = '';
// æ­¤å¤„å¡«ä½ æ¥æ”¶é€šçŸ¥æ¶ˆæ¯çš„telegramç”¨æˆ·çš„idï¼Œtelegramæœºå™¨äººé€šçŸ¥æ¨é€å¿…å¡«é¡¹.ä¾‹å¦‚ï¼š129xxx206
// (ç¯å¢ƒå˜é‡å TG_USER_ID)
let TG_USER_ID = '';
// tgæ¨é€HTTPä»£ç†è®¾ç½®(ä¸æ‡‚å¯å¿½ç•¥,telegramæœºå™¨äººé€šçŸ¥æ¨é€åŠŸèƒ½ä¸­éå¿…å¡«)
let TG_PROXY_HOST = ''; // ä¾‹å¦‚:127.0.0.1(ç¯å¢ƒå˜é‡å:TG_PROXY_HOST)
let TG_PROXY_PORT = ''; // ä¾‹å¦‚:1080(ç¯å¢ƒå˜é‡å:TG_PROXY_PORT)
let TG_PROXY_AUTH = ''; // tgä»£ç†é…ç½®è®¤è¯å‚æ•°
// Telegram apiè‡ªå»ºçš„åå‘ä»£ç†åœ°å€(ä¸æ‡‚å¯å¿½ç•¥,telegramæœºå™¨äººé€šçŸ¥æ¨é€åŠŸèƒ½ä¸­éå¿…å¡«),é»˜è®¤tgå®˜æ–¹api(ç¯å¢ƒå˜é‡å:TG_API_HOST)
let TG_API_HOST = 'https://api.telegram.org';
// =======================================é’‰é’‰æœºå™¨äººé€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
// æ­¤å¤„å¡«ä½ é’‰é’‰ bot çš„webhookï¼Œä¾‹å¦‚ï¼š5a544165465465645d0f31dca676e7bd07415asdasd
// (ç¯å¢ƒå˜é‡å DD_BOT_TOKEN)
let DD_BOT_TOKEN = '';
// å¯†é’¥ï¼Œæœºå™¨äººå®‰å…¨è®¾ç½®é¡µé¢ï¼ŒåŠ ç­¾ä¸€æ ä¸‹é¢æ˜¾ç¤ºçš„SECå¼€å¤´çš„å­—ç¬¦ä¸²
let DD_BOT_SECRET = '';

// =======================================ä¼ä¸šå¾®ä¿¡åŸºç¡€è®¾ç½®===========================================
// ä¼ä¸šå¾®ä¿¡åå‘ä»£ç†åœ°å€
// (ç¯å¢ƒå˜é‡å QYWX_ORIGIN)
let QYWX_ORIGIN = '';
// =======================================ä¼ä¸šå¾®ä¿¡æœºå™¨äººé€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
// æ­¤å¤„å¡«ä½ ä¼ä¸šå¾®ä¿¡æœºå™¨äººçš„ webhook(è¯¦è§æ–‡æ¡£ https://work.weixin.qq.com/api/doc/90000/90136/91770)ï¼Œä¾‹å¦‚ï¼š693a91f6-7xxx-4bc4-97a0-0ec2sifa5aaa
// (ç¯å¢ƒå˜é‡å QYWX_KEY)
let QYWX_KEY = '';

// =======================================ä¼ä¸šå¾®ä¿¡åº”ç”¨æ¶ˆæ¯é€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
/*
 æ­¤å¤„å¡«ä½ ä¼ä¸šå¾®ä¿¡åº”ç”¨æ¶ˆæ¯çš„å€¼(è¯¦è§æ–‡æ¡£ https://work.weixin.qq.com/api/doc/90000/90135/90236)
 ç¯å¢ƒå˜é‡å QYWX_AMä¾æ¬¡å¡«å…¥ corpid,corpsecret,touser(æ³¨:å¤šä¸ªæˆå‘˜IDä½¿ç”¨|éš”å¼€),agentid,æ¶ˆæ¯ç±»å‹(é€‰å¡«,ä¸å¡«é»˜è®¤æ–‡æœ¬æ¶ˆæ¯ç±»å‹)
 æ³¨æ„ç”¨,å·éš”å¼€(è‹±æ–‡è¾“å…¥æ³•çš„é€—å·)ï¼Œä¾‹å¦‚ï¼šwwcff56746d9adwers,B-791548lnzXBE6_BWfxdf3kSTMJr9vFEPKAbh6WERQ,mingcheng,1000001,2COXgjH2UIfERF2zxrtUOKgQ9XklUqMdGSWLBoW_lSDAdafat
 å¯é€‰æ¨é€æ¶ˆæ¯ç±»å‹(æ¨èä½¿ç”¨å›¾æ–‡æ¶ˆæ¯ï¼ˆmpnewsï¼‰):
 - æ–‡æœ¬å¡ç‰‡æ¶ˆæ¯: 0 (æ•°å­—é›¶)
 - æ–‡æœ¬æ¶ˆæ¯: 1 (æ•°å­—ä¸€)
 - å›¾æ–‡æ¶ˆæ¯ï¼ˆmpnewsï¼‰: ç´ æåº“å›¾ç‰‡id, å¯æŸ¥çœ‹æ­¤æ•™ç¨‹(http://note.youdao.com/s/HMiudGkb)æˆ–è€…(https://note.youdao.com/ynoteshare1/index.html?id=1a0c8aff284ad28cbd011b29b3ad0191&type=note)
 */
let QYWX_AM = '';

// =======================================iGotèšåˆæ¨é€é€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
// æ­¤å¤„å¡«æ‚¨iGotçš„ä¿¡æ¯(æ¨é€keyï¼Œä¾‹å¦‚ï¼šhttps://push.hellyw.com/XXXXXXXX)
let IGOT_PUSH_KEY = '';

// =======================================push+è®¾ç½®åŒºåŸŸ=======================================
// å®˜æ–¹æ–‡æ¡£ï¼šhttp://www.pushplus.plus/
// PUSH_PLUS_TOKENï¼šå¾®ä¿¡æ‰«ç ç™»å½•åä¸€å¯¹ä¸€æ¨é€æˆ–ä¸€å¯¹å¤šæ¨é€ä¸‹é¢çš„token(æ‚¨çš„Token)ï¼Œä¸æä¾›PUSH_PLUS_USERåˆ™é»˜è®¤ä¸ºä¸€å¯¹ä¸€æ¨é€
// PUSH_PLUS_USERï¼š ä¸€å¯¹å¤šæ¨é€çš„â€œç¾¤ç»„ç¼–ç â€ï¼ˆä¸€å¯¹å¤šæ¨é€ä¸‹é¢->æ‚¨çš„ç¾¤ç»„(å¦‚æ— åˆ™æ–°å»º)->ç¾¤ç»„ç¼–ç ï¼Œå¦‚æœæ‚¨æ˜¯åˆ›å»ºç¾¤ç»„äººã€‚ä¹Ÿéœ€ç‚¹å‡»â€œæŸ¥çœ‹äºŒç»´ç â€æ‰«æç»‘å®šï¼Œå¦åˆ™ä¸èƒ½æ¥å—ç¾¤ç»„æ¶ˆæ¯æ¨é€ï¼‰
let PUSH_PLUS_TOKEN = '';
let PUSH_PLUS_USER = '';

// =======================================æ™ºèƒ½å¾®ç§˜ä¹¦è®¾ç½®åŒºåŸŸ=======================================
// å®˜æ–¹æ–‡æ¡£ï¼šhttp://wechat.aibotk.com/docs/about
// AIBOTK_KEYï¼š å¡«å†™æ™ºèƒ½å¾®ç§˜ä¹¦ä¸ªäººä¸­å¿ƒçš„apikey
// AIBOTK_TYPEï¼šå¡«å†™å‘é€çš„ç›®æ ‡ room æˆ– contact, å¡«å…¶ä»–çš„ä¸ç”Ÿæ•ˆ
// AIBOTK_NAME: å¡«å†™ç¾¤åæˆ–ç”¨æˆ·æ˜µç§°ï¼Œå’Œä¸Šé¢çš„typeç±»å‹è¦å¯¹åº”
let AIBOTK_KEY = '';
let AIBOTK_TYPE = '';
let AIBOTK_NAME = '';

// =======================================é£ä¹¦æœºå™¨äººè®¾ç½®åŒºåŸŸ=======================================
// å®˜æ–¹æ–‡æ¡£ï¼šhttps://www.feishu.cn/hc/zh-CN/articles/360024984973
// FSKEY é£ä¹¦æœºå™¨äººçš„ FSKEY
let FSKEY = '';

// =======================================SMTP é‚®ä»¶è®¾ç½®åŒºåŸŸ=======================================
// SMTP_SERVICE: é‚®ç®±æœåŠ¡åç§°ï¼Œæ¯”å¦‚126ã€163ã€Gmailã€QQç­‰ï¼Œæ”¯æŒåˆ—è¡¨ https://github.com/nodemailer/nodemailer/blob/master/lib/well-known/services.json
// SMTP_EMAIL: å¡«å†™ SMTP æ”¶å‘ä»¶é‚®ç®±ï¼Œé€šçŸ¥å°†ä¼šç”±è‡ªå·±å‘ç»™è‡ªå·±
// SMTP_PASSWORD: å¡«å†™ SMTP ç™»å½•å¯†ç ï¼Œä¹Ÿå¯èƒ½ä¸ºç‰¹æ®Šå£ä»¤ï¼Œè§†å…·ä½“é‚®ä»¶æœåŠ¡å•†è¯´æ˜è€Œå®š
// SMTP_NAME: å¡«å†™ SMTP æ”¶å‘ä»¶äººå§“åï¼Œå¯éšæ„å¡«å†™
let SMTP_SERVICE = '';
let SMTP_EMAIL = '';
let SMTP_PASSWORD = '';
let SMTP_NAME = '';

// =======================================PushMeé€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
// å®˜æ–¹æ–‡æ¡£ï¼šhttps://push.i-i.me/
// æ­¤å¤„å¡«ä½ çš„PushMe KEY.
let PUSHME_KEY = '';

// =======================================CHRONOCATé€šçŸ¥è®¾ç½®åŒºåŸŸ===========================================
// CHRONOCAT_URL Redåè®®è¿æ¥åœ°å€ ä¾‹ï¼š http://127.0.0.1:16530
// CHRONOCAT_TOKEN å¡«å†™åœ¨CHRONOCATæ–‡ä»¶ç”Ÿæˆçš„è®¿é—®å¯†é’¥
// CHRONOCAT_QQ ä¸ªäºº:user_id=ä¸ªäººQQ ç¾¤åˆ™å¡«å…¥group_id=QQç¾¤ å¤šä¸ªç”¨è‹±æ–‡;éš”å¼€åŒæ—¶æ”¯æŒä¸ªäººå’Œç¾¤
// CHRONOCATç›¸å…³API https://chronocat.vercel.app/install/docker/official/
let CHRONOCAT_URL = ''; // CHRONOCAT Redåè®®è¿æ¥åœ°å€
let CHRONOCAT_TOKEN = ''; // CHRONOCAT ç”Ÿæˆçš„è®¿é—®å¯†é’¥
let CHRONOCAT_QQ = ''; // ä¸ªäºº:user_id=ä¸ªäººQQ ç¾¤åˆ™å¡«å…¥group_id=QQç¾¤ å¤šä¸ªç”¨è‹±æ–‡;éš”å¼€åŒæ—¶æ”¯æŒä¸ªäººå’Œç¾¤ å¦‚ï¼šuser_id=xxx;group_id=xxxx;group_id=xxxxx

// =======================================è‡ªå®šä¹‰é€šçŸ¥è®¾ç½®åŒºåŸŸ=======================================
// è‡ªå®šä¹‰é€šçŸ¥ æ¥æ”¶å›è°ƒçš„URL
let WEBHOOK_URL = '';
let WEBHOOK_BODY = '';
let WEBHOOK_HEADERS = '';
let WEBHOOK_METHOD = '';
let WEBHOOK_CONTENT_TYPE = '';

// ==========================äº‘ç«¯ç¯å¢ƒå˜é‡çš„åˆ¤æ–­ä¸æ¥æ”¶=========================
if (process.env.GOTIFY_URL) {
  GOTIFY_URL = process.env.GOTIFY_URL;
}
if (process.env.GOTIFY_TOKEN) {
  GOTIFY_TOKEN = process.env.GOTIFY_TOKEN;
}
if (process.env.GOTIFY_PRIORITY) {
  GOTIFY_PRIORITY = process.env.GOTIFY_PRIORITY;
}

if (process.env.GOBOT_URL) {
  GOBOT_URL = process.env.GOBOT_URL;
}
if (process.env.GOBOT_TOKEN) {
  GOBOT_TOKEN = process.env.GOBOT_TOKEN;
}
if (process.env.GOBOT_QQ) {
  GOBOT_QQ = process.env.GOBOT_QQ;
}

if (process.env.PUSH_KEY) {
  SCKEY = process.env.PUSH_KEY;
}

if (process.env.DEER_KEY) {
  PUSHDEER_KEY = process.env.DEER_KEY;
  PUSHDEER_URL = process.env.DEER_URL;
}

if (process.env.CHAT_URL) {
  CHAT_URL = process.env.CHAT_URL;
}

if (process.env.CHAT_TOKEN) {
  CHAT_TOKEN = process.env.CHAT_TOKEN;
}

if (process.env.QQ_SKEY) {
  QQ_SKEY = process.env.QQ_SKEY;
}

if (process.env.QQ_MODE) {
  QQ_MODE = process.env.QQ_MODE;
}

if (process.env.BARK_PUSH) {
  if (
    process.env.BARK_PUSH.indexOf('https') > -1 ||
    process.env.BARK_PUSH.indexOf('http') > -1
  ) {
    // å…¼å®¹BARKè‡ªå»ºç”¨æˆ·
    BARK_PUSH = process.env.BARK_PUSH;
  } else {
    BARK_PUSH = `https://api.day.app/${process.env.BARK_PUSH}`;
  }
  if (process.env.BARK_ICON) {
    BARK_ICON = process.env.BARK_ICON;
  }
  if (process.env.BARK_SOUND) {
    BARK_SOUND = process.env.BARK_SOUND;
  }
  if (process.env.BARK_GROUP) {
    BARK_GROUP = process.env.BARK_GROUP;
  }
  if (process.env.BARK_LEVEL) {
    BARK_LEVEL = process.env.BARK_LEVEL;
  }
  if (process.env.BARK_URL) {
    BARK_URL = process.env.BARK_URL;
  }
} else {
  if (
    BARK_PUSH &&
    BARK_PUSH.indexOf('https') === -1 &&
    BARK_PUSH.indexOf('http') === -1
  ) {
    // å…¼å®¹BARKæœ¬åœ°ç”¨æˆ·åªå¡«å†™è®¾å¤‡ç çš„æƒ…å†µ
    BARK_PUSH = `https://api.day.app/${BARK_PUSH}`;
  }
}
if (process.env.TG_BOT_TOKEN) {
  TG_BOT_TOKEN = process.env.TG_BOT_TOKEN;
}
if (process.env.TG_USER_ID) {
  TG_USER_ID = process.env.TG_USER_ID;
}
if (process.env.TG_PROXY_AUTH) TG_PROXY_AUTH = process.env.TG_PROXY_AUTH;
if (process.env.TG_PROXY_HOST) TG_PROXY_HOST = process.env.TG_PROXY_HOST;
if (process.env.TG_PROXY_PORT) TG_PROXY_PORT = process.env.TG_PROXY_PORT;
if (process.env.TG_API_HOST) TG_API_HOST = process.env.TG_API_HOST;

if (process.env.DD_BOT_TOKEN) {
  DD_BOT_TOKEN = process.env.DD_BOT_TOKEN;
  if (process.env.DD_BOT_SECRET) {
    DD_BOT_SECRET = process.env.DD_BOT_SECRET;
  }
}

if (process.env.QYWX_ORIGIN) {
  QYWX_ORIGIN = process.env.QYWX_ORIGIN;
} else {
  QYWX_ORIGIN = 'https://qyapi.weixin.qq.com';
}

if (process.env.QYWX_KEY) {
  QYWX_KEY = process.env.QYWX_KEY;
}

if (process.env.QYWX_AM) {
  QYWX_AM = process.env.QYWX_AM;
}

if (process.env.IGOT_PUSH_KEY) {
  IGOT_PUSH_KEY = process.env.IGOT_PUSH_KEY;
}

if (process.env.PUSH_PLUS_TOKEN) {
  PUSH_PLUS_TOKEN = process.env.PUSH_PLUS_TOKEN;
}
if (process.env.PUSH_PLUS_USER) {
  PUSH_PLUS_USER = process.env.PUSH_PLUS_USER;
}

if (process.env.AIBOTK_KEY) {
  AIBOTK_KEY = process.env.AIBOTK_KEY;
}
if (process.env.AIBOTK_TYPE) {
  AIBOTK_TYPE = process.env.AIBOTK_TYPE;
}
if (process.env.AIBOTK_NAME) {
  AIBOTK_NAME = process.env.AIBOTK_NAME;
}

if (process.env.FSKEY) {
  FSKEY = process.env.FSKEY;
}

if (process.env.SMTP_SERVICE) {
  SMTP_SERVICE = process.env.SMTP_SERVICE;
}
if (process.env.SMTP_EMAIL) {
  SMTP_EMAIL = process.env.SMTP_EMAIL;
}
if (process.env.SMTP_PASSWORD) {
  SMTP_PASSWORD = process.env.SMTP_PASSWORD;
}
if (process.env.SMTP_NAME) {
  SMTP_NAME = process.env.SMTP_NAME;
}
if (process.env.PUSHME_KEY) {
  PUSHME_KEY = process.env.PUSHME_KEY;
}

if (process.env.CHRONOCAT_URL) {
  CHRONOCAT_URL = process.env.CHRONOCAT_URL;
}
if (process.env.CHRONOCAT_QQ) {
  CHRONOCAT_QQ = process.env.CHRONOCAT_QQ;
}
if (process.env.CHRONOCAT_TOKEN) {
  CHRONOCAT_TOKEN = process.env.CHRONOCAT_TOKEN;
}

if (process.env.WEBHOOK_URL) {
  WEBHOOK_URL = process.env.WEBHOOK_URL;
}
if (process.env.WEBHOOK_BODY) {
  WEBHOOK_BODY = process.env.WEBHOOK_BODY;
}
if (process.env.WEBHOOK_HEADERS) {
  WEBHOOK_HEADERS = process.env.WEBHOOK_HEADERS;
}
if (process.env.WEBHOOK_METHOD) {
  WEBHOOK_METHOD = process.env.WEBHOOK_METHOD;
}
if (process.env.WEBHOOK_CONTENT_TYPE) {
  WEBHOOK_CONTENT_TYPE = process.env.WEBHOOK_CONTENT_TYPE;
}
// ==========================äº‘ç«¯ç¯å¢ƒå˜é‡çš„åˆ¤æ–­ä¸æ¥æ”¶=========================

/**
 * sendNotify æ¨é€é€šçŸ¥åŠŸèƒ½
 * @param text é€šçŸ¥å¤´
 * @param desp é€šçŸ¥ä½“
 * @param params æŸäº›æ¨é€é€šçŸ¥æ–¹å¼ç‚¹å‡»å¼¹çª—å¯è·³è½¬, ä¾‹ï¼š{ url: 'https://abc.com' }
 * @param author ä½œè€…ä»“åº“ç­‰ä¿¡æ¯  ä¾‹ï¼š`æœ¬é€šçŸ¥ Byï¼šhttps://github.com/whyour/qinglong`
 * @returns {Promise<unknown>}
 */
async function sendNotify(
  text,
  desp,
  params = {},
  author = '\n\næœ¬é€šçŸ¥ Byï¼škyleç»¼åˆ',
) {
  // æä¾›6ç§é€šçŸ¥
  desp += author; // å¢åŠ ä½œè€…ä¿¡æ¯ï¼Œé˜²æ­¢è¢«è´©å–ç­‰

  // æ ¹æ®æ ‡é¢˜è·³è¿‡ä¸€äº›æ¶ˆæ¯æ¨é€ï¼Œç¯å¢ƒå˜é‡ï¼šSKIP_PUSH_TITLE ç”¨å›è½¦åˆ†éš”
  let skipTitle = process.env.SKIP_PUSH_TITLE;
  if (skipTitle) {
    if (skipTitle.split('\n').includes(text)) {
      console.info(text + 'åœ¨SKIP_PUSH_TITLEç¯å¢ƒå˜é‡å†…ï¼Œè·³è¿‡æ¨é€ï¼');
      return;
    }
  }

  await Promise.all([
    serverNotify(text, desp), // å¾®ä¿¡serveré…±
    pushPlusNotify(text, desp), // pushplus(æ¨é€åŠ )
  ]);
  // ç”±äºä¸Šè¿°ä¸¤ç§å¾®ä¿¡é€šçŸ¥éœ€ç‚¹å‡»è¿›å»æ‰èƒ½æŸ¥çœ‹åˆ°è¯¦æƒ…ï¼Œæ•…text(æ ‡é¢˜å†…å®¹)æºå¸¦äº†è´¦å·åºå·ä»¥åŠæ˜µç§°ä¿¡æ¯ï¼Œæ–¹ä¾¿ä¸ç‚¹å‡»ä¹Ÿå¯çŸ¥é“æ˜¯å“ªä¸ªäº¬ä¸œå“ªä¸ªæ´»åŠ¨
  text = text.match(/.*?(?=\s?-)/g) ? text.match(/.*?(?=\s?-)/g)[0] : text;
  await Promise.all([
    BarkNotify(text, desp, params), // iOS Bark APP
    tgBotNotify(text, desp), // telegram æœºå™¨äºº
    ddBotNotify(text, desp), // é’‰é’‰æœºå™¨äºº
    qywxBotNotify(text, desp), // ä¼ä¸šå¾®ä¿¡æœºå™¨äºº
    qywxamNotify(text, desp), // ä¼ä¸šå¾®ä¿¡åº”ç”¨æ¶ˆæ¯æ¨é€
    iGotNotify(text, desp, params), // iGot
    gobotNotify(text, desp), // go-cqhttp
    gotifyNotify(text, desp), // gotify
    ChatNotify(text, desp), // synolog chat
    PushDeerNotify(text, desp), // PushDeer
    aibotkNotify(text, desp), // æ™ºèƒ½å¾®ç§˜ä¹¦
    fsBotNotify(text, desp), // é£ä¹¦æœºå™¨äºº
    smtpNotify(text, desp), // SMTP é‚®ä»¶
    pushMeNotify(text, desp, params), // PushMe
    chronocatNotify(text, desp), // Chronocat
    webhookNotify(text, desp), // è‡ªå®šä¹‰é€šçŸ¥
  ]);
}

function gotifyNotify(text, desp) {
  return new Promise((resolve) => {
    if (GOTIFY_URL && GOTIFY_TOKEN) {
      const options = {
        url: `${GOTIFY_URL}/message?token=${GOTIFY_TOKEN}`,
        body: `title=${encodeURIComponent(text)}&message=${encodeURIComponent(
          desp,
        )}&priority=${GOTIFY_PRIORITY}`,
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      };
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('gotifyå‘é€é€šçŸ¥è°ƒç”¨APIå¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.id) {
              console.log('gotifyå‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰\n');
            } else {
              console.log(`${data.message}\n`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve();
        }
      });
    } else {
      resolve();
    }
  });
}

function gobotNotify(text, desp) {
  return new Promise((resolve) => {
    if (GOBOT_URL) {
      const options = {
        url: `${GOBOT_URL}?access_token=${GOBOT_TOKEN}&${GOBOT_QQ}`,
        json: { message: `${text}\n${desp}` },
        headers: {
          'Content-Type': 'application/json',
        },
        timeout,
      };
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('å‘é€go-cqhttpé€šçŸ¥è°ƒç”¨APIå¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.retcode === 0) {
              console.log('go-cqhttpå‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰\n');
            } else if (data.retcode === 100) {
              console.log(`go-cqhttpå‘é€é€šçŸ¥æ¶ˆæ¯å¼‚å¸¸: ${data.errmsg}\n`);
            } else {
              console.log(`go-cqhttpå‘é€é€šçŸ¥æ¶ˆæ¯å¼‚å¸¸\n${JSON.stringify(data)}`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}

function serverNotify(text, desp) {
  return new Promise((resolve) => {
    if (SCKEY) {
      // å¾®ä¿¡serveré…±æ¨é€é€šçŸ¥ä¸€ä¸ª\nä¸ä¼šæ¢è¡Œï¼Œéœ€è¦ä¸¤ä¸ª\næ‰èƒ½æ¢è¡Œï¼Œæ•…åšæ­¤æ›¿æ¢
      desp = desp.replace(/[\n\r]/g, '\n\n');
      const options = {
        url: SCKEY.includes('SCT')
          ? `https://sctapi.ftqq.com/${SCKEY}.send`
          : `https://sc.ftqq.com/${SCKEY}.send`,
        body: `text=${text}&desp=${desp}`,
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        timeout,
      };
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('å‘é€é€šçŸ¥è°ƒç”¨APIå¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            // serveré…±å’ŒServeré…±Â·Turboç‰ˆçš„è¿”å›jsonæ ¼å¼ä¸å¤ªä¸€æ ·
            if (data.errno === 0 || data.data.errno === 0) {
              console.log('serveré…±å‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰\n');
            } else if (data.errno === 1024) {
              // ä¸€åˆ†é’Ÿå†…å‘é€ç›¸åŒçš„å†…å®¹ä¼šè§¦å‘
              console.log(`serveré…±å‘é€é€šçŸ¥æ¶ˆæ¯å¼‚å¸¸: ${data.errmsg}\n`);
            } else {
              console.log(`serveré…±å‘é€é€šçŸ¥æ¶ˆæ¯å¼‚å¸¸\n${JSON.stringify(data)}`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}

function PushDeerNotify(text, desp) {
  return new Promise((resolve) => {
    if (PUSHDEER_KEY) {
      // PushDeer å»ºè®®å¯¹æ¶ˆæ¯å†…å®¹è¿›è¡Œ urlencode
      desp = encodeURI(desp);
      const options = {
        url: PUSHDEER_URL || `https://api2.pushdeer.com/message/push`,
        body: `pushkey=${PUSHDEER_KEY}&text=${text}&desp=${desp}&type=markdown`,
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        timeout,
      };
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('å‘é€é€šçŸ¥è°ƒç”¨APIå¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            // é€šè¿‡è¿”å›çš„resultçš„é•¿åº¦æ¥åˆ¤æ–­æ˜¯å¦æˆåŠŸ
            if (
              data.content.result.length !== undefined &&
              data.content.result.length > 0
            ) {
              console.log('PushDeerå‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰\n');
            } else {
              console.log(`PushDeerå‘é€é€šçŸ¥æ¶ˆæ¯å¼‚å¸¸\n${JSON.stringify(data)}`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}

function ChatNotify(text, desp) {
  return new Promise((resolve) => {
    if (CHAT_URL && CHAT_TOKEN) {
      // å¯¹æ¶ˆæ¯å†…å®¹è¿›è¡Œ urlencode
      desp = encodeURI(desp);
      const options = {
        url: `${CHAT_URL}${CHAT_TOKEN}`,
        body: `payload={"text":"${text}\n${desp}"}`,
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      };
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('å‘é€é€šçŸ¥è°ƒç”¨APIå¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.success) {
              console.log('Chatå‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰\n');
            } else {
              console.log(`Chatå‘é€é€šçŸ¥æ¶ˆæ¯å¼‚å¸¸\n${JSON.stringify(data)}`);
            }
          }
        } catch (e) {
          $.logErr(e);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}

function BarkNotify(text, desp, params = {}) {
  return new Promise((resolve) => {
    if (BARK_PUSH) {
      const options = {
        url: `${BARK_PUSH}/${encodeURIComponent(text)}/${encodeURIComponent(
          desp,
        )}?icon=${BARK_ICON}&sound=${BARK_SOUND}&group=${BARK_GROUP}&level=${BARK_LEVEL}&url=${BARK_URL}&${querystring.stringify(
          params,
        )}`,
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        timeout,
      };
      $.get(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('Bark APPå‘é€é€šçŸ¥è°ƒç”¨APIå¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.code === 200) {
              console.log('Bark APPå‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰\n');
            } else {
              console.log(`${data.message}\n`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve();
        }
      });
    } else {
      resolve();
    }
  });
}

function tgBotNotify(text, desp) {
  return new Promise((resolve) => {
    if (TG_BOT_TOKEN && TG_USER_ID) {
      const options = {
        url: `${TG_API_HOST}/bot${TG_BOT_TOKEN}/sendMessage`,
        json: {
          chat_id: `${TG_USER_ID}`,
          text: `${text}\n\n${desp}`,
          disable_web_page_preview: true,
        },
        headers: {
          'Content-Type': 'application/json',
        },
        timeout,
      };
      if (TG_PROXY_HOST && TG_PROXY_PORT) {
        const { HttpProxyAgent, HttpsProxyAgent } = require('hpagent');
        const options = {
          keepAlive: true,
          keepAliveMsecs: 1000,
          maxSockets: 256,
          maxFreeSockets: 256,
          proxy: `http://${TG_PROXY_AUTH}${TG_PROXY_HOST}:${TG_PROXY_PORT}`,
        };
        const httpAgent = new HttpProxyAgent(options);
        const httpsAgent = new HttpsProxyAgent(options);
        const agent = {
          http: httpAgent,
          https: httpsAgent,
        };
        Object.assign(options, { agent });
      }
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('telegramå‘é€é€šçŸ¥æ¶ˆæ¯å¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.ok) {
              console.log('Telegramå‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰ã€‚\n');
            } else if (data.error_code === 400) {
              console.log(
                'è¯·ä¸»åŠ¨ç»™botå‘é€ä¸€æ¡æ¶ˆæ¯å¹¶æ£€æŸ¥æ¥æ”¶ç”¨æˆ·IDæ˜¯å¦æ­£ç¡®ã€‚\n',
              );
            } else if (data.error_code === 401) {
              console.log('Telegram bot token å¡«å†™é”™è¯¯ã€‚\n');
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}
function ddBotNotify(text, desp) {
  return new Promise((resolve) => {
    const options = {
      url: `https://oapi.dingtalk.com/robot/send?access_token=${DD_BOT_TOKEN}`,
      json: {
        msgtype: 'text',
        text: {
          content: `${text}\n\n${desp}`,
        },
      },
      headers: {
        'Content-Type': 'application/json',
      },
      timeout,
    };
    if (DD_BOT_TOKEN && DD_BOT_SECRET) {
      const crypto = require('crypto');
      const dateNow = Date.now();
      const hmac = crypto.createHmac('sha256', DD_BOT_SECRET);
      hmac.update(`${dateNow}\n${DD_BOT_SECRET}`);
      const result = encodeURIComponent(hmac.digest('base64'));
      options.url = `${options.url}&timestamp=${dateNow}&sign=${result}`;
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('é’‰é’‰å‘é€é€šçŸ¥æ¶ˆæ¯å¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.errcode === 0) {
              console.log('é’‰é’‰å‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰ã€‚\n');
            } else {
              console.log(`${data.errmsg}\n`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else if (DD_BOT_TOKEN) {
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('é’‰é’‰å‘é€é€šçŸ¥æ¶ˆæ¯å¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.errcode === 0) {
              console.log('é’‰é’‰å‘é€é€šçŸ¥æ¶ˆæ¯å®Œæˆã€‚\n');
            } else {
              console.log(`${data.errmsg}\n`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}

function qywxBotNotify(text, desp) {
  return new Promise((resolve) => {
    const options = {
      url: `${QYWX_ORIGIN}/cgi-bin/webhook/send?key=${QYWX_KEY}`,
      json: {
        msgtype: 'text',
        text: {
          content: `${text}\n\n${desp}`,
        },
      },
      headers: {
        'Content-Type': 'application/json',
      },
      timeout,
    };
    if (QYWX_KEY) {
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('ä¼ä¸šå¾®ä¿¡å‘é€é€šçŸ¥æ¶ˆæ¯å¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.errcode === 0) {
              console.log('ä¼ä¸šå¾®ä¿¡å‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰ã€‚\n');
            } else {
              console.log(`${data.errmsg}\n`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}

function ChangeUserId(desp) {
  const QYWX_AM_AY = QYWX_AM.split(',');
  if (QYWX_AM_AY[2]) {
    const userIdTmp = QYWX_AM_AY[2].split('|');
    let userId = '';
    for (let i = 0; i < userIdTmp.length; i++) {
      const count = 'è´¦å·' + (i + 1);
      const count2 = 'ç­¾åˆ°å· ' + (i + 1);
      if (desp.match(count2)) {
        userId = userIdTmp[i];
      }
    }
    if (!userId) userId = QYWX_AM_AY[2];
    return userId;
  } else {
    return '@all';
  }
}

async function qywxamNotify(text, desp) {
  const MAX_LENGTH = 900;
  if (desp.length > MAX_LENGTH) {
    let d = desp.substr(0, MAX_LENGTH) + '\n==More==';
    await do_qywxamNotify(text, d);
    await qywxamNotify(text, desp.substr(MAX_LENGTH));
  } else {
    return await do_qywxamNotify(text, desp);
  }
}

function do_qywxamNotify(text, desp) {
  return new Promise((resolve) => {
    if (QYWX_AM) {
      const QYWX_AM_AY = QYWX_AM.split(',');
      const options_accesstoken = {
        url: `${QYWX_ORIGIN}/cgi-bin/gettoken`,
        json: {
          corpid: `${QYWX_AM_AY[0]}`,
          corpsecret: `${QYWX_AM_AY[1]}`,
        },
        headers: {
          'Content-Type': 'application/json',
        },
        timeout,
      };
      $.post(options_accesstoken, (err, resp, data) => {
        let html = desp.replace(/\n/g, '<br/>');
        let json = JSON.parse(data);
        let accesstoken = json.access_token;
        let options;

        switch (QYWX_AM_AY[4]) {
          case '0':
            options = {
              msgtype: 'textcard',
              textcard: {
                title: `${text}`,
                description: `${desp}`,
                url: 'https://github.com/whyour/qinglong',
                btntxt: 'æ›´å¤š',
              },
            };
            break;

          case '1':
            options = {
              msgtype: 'text',
              text: {
                content: `${text}\n\n${desp}`,
              },
            };
            break;

          default:
            options = {
              msgtype: 'mpnews',
              mpnews: {
                articles: [
                  {
                    title: `${text}`,
                    thumb_media_id: `${QYWX_AM_AY[4]}`,
                    author: `æ™ºèƒ½åŠ©æ‰‹`,
                    content_source_url: ``,
                    content: `${html}`,
                    digest: `${desp}`,
                  },
                ],
              },
            };
        }
        if (!QYWX_AM_AY[4]) {
          // å¦‚ä¸æä¾›ç¬¬å››ä¸ªå‚æ•°,åˆ™é»˜è®¤è¿›è¡Œæ–‡æœ¬æ¶ˆæ¯ç±»å‹æ¨é€
          options = {
            msgtype: 'text',
            text: {
              content: `${text}\n\n${desp}`,
            },
          };
        }
        options = {
          url: `${QYWX_ORIGIN}/cgi-bin/message/send?access_token=${accesstoken}`,
          json: {
            touser: `${ChangeUserId(desp)}`,
            agentid: `${QYWX_AM_AY[3]}`,
            safe: '0',
            ...options,
          },
          headers: {
            'Content-Type': 'application/json',
          },
        };

        $.post(options, (err, resp, data) => {
          try {
            if (err) {
              console.log(
                'æˆå‘˜ID:' +
                  ChangeUserId(desp) +
                  'ä¼ä¸šå¾®ä¿¡åº”ç”¨æ¶ˆæ¯å‘é€é€šçŸ¥æ¶ˆæ¯å¤±è´¥ï¼ï¼\n',
              );
              console.log(err);
            } else {
              data = JSON.parse(data);
              if (data.errcode === 0) {
                console.log(
                  'æˆå‘˜ID:' +
                    ChangeUserId(desp) +
                    'ä¼ä¸šå¾®ä¿¡åº”ç”¨æ¶ˆæ¯å‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰ã€‚\n',
                );
              } else {
                console.log(`${data.errmsg}\n`);
              }
            }
          } catch (e) {
            $.logErr(e, resp);
          } finally {
            resolve(data);
          }
        });
      });
    } else {
      resolve();
    }
  });
}

function iGotNotify(text, desp, params = {}) {
  return new Promise((resolve) => {
    if (IGOT_PUSH_KEY) {
      // æ ¡éªŒä¼ å…¥çš„IGOT_PUSH_KEYæ˜¯å¦æœ‰æ•ˆ
      const IGOT_PUSH_KEY_REGX = new RegExp('^[a-zA-Z0-9]{24}$');
      if (!IGOT_PUSH_KEY_REGX.test(IGOT_PUSH_KEY)) {
        console.log('æ‚¨æ‰€æä¾›çš„IGOT_PUSH_KEYæ— æ•ˆ\n');
        resolve();
        return;
      }
      const options = {
        url: `https://push.hellyw.com/${IGOT_PUSH_KEY.toLowerCase()}`,
        body: `title=${text}&content=${desp}&${querystring.stringify(params)}`,
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        timeout,
      };
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('å‘é€é€šçŸ¥è°ƒç”¨APIå¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            if (typeof data === 'string') data = JSON.parse(data);
            if (data.ret === 0) {
              console.log('iGotå‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰\n');
            } else {
              console.log(`iGotå‘é€é€šçŸ¥æ¶ˆæ¯å¤±è´¥ï¼š${data.errMsg}\n`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}

function pushPlusNotify(text, desp) {
  return new Promise((resolve) => {
    if (PUSH_PLUS_TOKEN) {
      desp = desp.replace(/[\n\r]/g, '<br>'); // é»˜è®¤ä¸ºhtml, ä¸æ”¯æŒplaintext
      const body = {
        token: `${PUSH_PLUS_TOKEN}`,
        title: `${text}`,
        content: `${desp}`,
        topic: `${PUSH_PLUS_USER}`,
      };
      const options = {
        url: `https://www.pushplus.plus/send`,
        body: JSON.stringify(body),
        headers: {
          'Content-Type': ' application/json',
        },
        timeout,
      };
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log(
              `push+å‘é€${
                PUSH_PLUS_USER ? 'ä¸€å¯¹å¤š' : 'ä¸€å¯¹ä¸€'
              }é€šçŸ¥æ¶ˆæ¯å¤±è´¥ï¼ï¼\n`,
            );
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.code === 200) {
              console.log(
                `push+å‘é€${
                  PUSH_PLUS_USER ? 'ä¸€å¯¹å¤š' : 'ä¸€å¯¹ä¸€'
                }é€šçŸ¥æ¶ˆæ¯å®Œæˆã€‚\n`,
              );
            } else {
              console.log(
                `push+å‘é€${
                  PUSH_PLUS_USER ? 'ä¸€å¯¹å¤š' : 'ä¸€å¯¹ä¸€'
                }é€šçŸ¥æ¶ˆæ¯å¤±è´¥ï¼š${data.msg}\n`,
              );
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}

function aibotkNotify(text, desp) {
  return new Promise((resolve) => {
    if (AIBOTK_KEY && AIBOTK_TYPE && AIBOTK_NAME) {
      let json = {};
      let url = '';
      switch (AIBOTK_TYPE) {
        case 'room':
          url = 'https://api-bot.aibotk.com/openapi/v1/chat/room';
          json = {
            apiKey: `${AIBOTK_KEY}`,
            roomName: `${AIBOTK_NAME}`,
            message: {
              type: 1,
              content: `ã€é’é¾™å¿«è®¯ã€‘\n\n${text}\n${desp}`,
            },
          };
          break;
        case 'contact':
          url = 'https://api-bot.aibotk.com/openapi/v1/chat/contact';
          json = {
            apiKey: `${AIBOTK_KEY}`,
            name: `${AIBOTK_NAME}`,
            message: {
              type: 1,
              content: `ã€é’é¾™å¿«è®¯ã€‘\n\n${text}\n${desp}`,
            },
          };
          break;
      }
      const options = {
        url: url,
        json,
        headers: {
          'Content-Type': 'application/json',
        },
        timeout,
      };
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('æ™ºèƒ½å¾®ç§˜ä¹¦å‘é€é€šçŸ¥æ¶ˆæ¯å¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.code === 0) {
              console.log('æ™ºèƒ½å¾®ç§˜ä¹¦å‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰ã€‚\n');
            } else {
              console.log(`${data.error}\n`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}

function fsBotNotify(text, desp) {
  return new Promise((resolve) => {
    if (FSKEY) {
      const options = {
        url: `https://open.feishu.cn/open-apis/bot/v2/hook/${FSKEY}`,
        json: { msg_type: 'text', content: { text: `${text}\n\n${desp}` } },
        headers: {
          'Content-Type': 'application/json',
        },
        timeout,
      };
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('å‘é€é€šçŸ¥è°ƒç”¨APIå¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.StatusCode === 0) {
              console.log('é£ä¹¦å‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰\n');
            } else {
              console.log(`${data.msg}\n`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}

async function smtpNotify(text, desp) {
  if (![SMTP_EMAIL, SMTP_PASSWORD].every(Boolean) || !SMTP_SERVICE) {
    return;
  }

  try {
    const nodemailer = require('nodemailer');
    const transporter = nodemailer.createTransport({
      service: SMTP_SERVICE,
      auth: {
        user: SMTP_EMAIL,
        pass: SMTP_PASSWORD,
      },
    });

    const addr = SMTP_NAME ? `"${SMTP_NAME}" <${SMTP_EMAIL}>` : SMTP_EMAIL;
    const info = await transporter.sendMail({
      from: addr,
      to: addr,
      subject: text,
      html: `${desp.replace(/\n/g, '<br/>')}`,
    });

    transporter.close();

    if (info.messageId) {
      console.log('SMTPå‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰\n');
      return true;
    }
    console.log('SMTPå‘é€é€šçŸ¥æ¶ˆæ¯å¤±è´¥ï¼ï¼\n');
  } catch (e) {
    console.log('SMTPå‘é€é€šçŸ¥æ¶ˆæ¯å‡ºç°é”™è¯¯ï¼ï¼\n');
    console.log(e);
  }
}

function pushMeNotify(text, desp, params = {}) {
  return new Promise((resolve) => {
    if (PUSHME_KEY) {
      const options = {
        url: `https://push.i-i.me?push_key=${PUSHME_KEY}`,
        json: { title: text, content: desp, ...params },
        headers: {
          'Content-Type': 'application/json',
        },
        timeout,
      };
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('PushMeNotifyå‘é€é€šçŸ¥è°ƒç”¨APIå¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            if (data === 'success') {
              console.log('PushMeå‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰\n');
            } else {
              console.log(`${data}\n`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve(data);
        }
      });
    } else {
      resolve();
    }
  });
}

function chronocatNotify(title, desp) {
  return new Promise((resolve) => {
    if (!CHRONOCAT_TOKEN || !CHRONOCAT_QQ || !CHRONOCAT_URL) {
      resolve();
      return;
    }

    const user_ids = CHRONOCAT_QQ.match(/user_id=(\d+)/g)?.map(
      (match) => match.split('=')[1],
    );
    const group_ids = CHRONOCAT_QQ.match(/group_id=(\d+)/g)?.map(
      (match) => match.split('=')[1],
    );

    const url = `${CHRONOCAT_URL}/api/message/send`;
    const headers = {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${CHRONOCAT_TOKEN}`,
    };

    for (const [chat_type, ids] of [
      [1, user_ids],
      [2, group_ids],
    ]) {
      if (!ids) {
        continue;
      }
      for (const chat_id of ids) {
        const data = {
          peer: {
            chatType: chat_type,
            peerUin: chat_id,
          },
          elements: [
            {
              elementType: 1,
              textElement: {
                content: `${title}\n\n${desp}`,
              },
            },
          ],
        };
        const options = {
          url: url,
          json: data,
          headers,
          timeout,
        };
        $.post(options, (err, resp, data) => {
          try {
            if (err) {
              console.log('Chronocatå‘é€QQé€šçŸ¥æ¶ˆæ¯å¤±è´¥ï¼ï¼\n');
              console.log(err);
            } else {
              data = JSON.parse(data);
              if (chat_type === 1) {
                console.log(`QQä¸ªäººæ¶ˆæ¯:${ids}æ¨é€æˆåŠŸï¼`);
              } else {
                console.log(`QQç¾¤æ¶ˆæ¯:${ids}æ¨é€æˆåŠŸï¼`);
              }
            }
          } catch (e) {
            $.logErr(e, resp);
          } finally {
            resolve(data);
          }
        });
      }
    }
  });
}

function webhookNotify(text, desp) {
  return new Promise((resolve) => {
    if (WEBHOOK_URL) {
      const options = {
        url: `${WEBHOOK_URL}`,
        body: `{"title":"${text}","content":"${desp}"}`,
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      };
      $.post(options, (err, resp, data) => {
        try {
          if (err) {
            console.log('kyleè‡ªå®šä¹‰å‘é€é€šçŸ¥è°ƒç”¨APIå¤±è´¥ï¼ï¼\n');
            console.log(err);
          } else {
            data = JSON.parse(data);
            if (data.code="200") {
              console.log('kyleè‡ªå®šä¹‰å‘é€é€šçŸ¥æ¶ˆæ¯æˆåŠŸğŸ‰\n');
            } else {
              console.log(`${data.message}\n`);
            }
          }
        } catch (e) {
          $.logErr(e, resp);
        } finally {
          resolve();
        }
      });
    } else {
      resolve();
    }
  });
}
function parseString(input, valueFormatFn) {
  const regex = /(\w+):\s*((?:(?!\n\w+:).)*)/g;
  const matches = {};

  let match;
  while ((match = regex.exec(input)) !== null) {
    const [, key, value] = match;
    const _key = key.trim();
    if (!_key || matches[_key]) {
      continue;
    }

    let _value = value.trim();

    try {
      _value = valueFormatFn ? valueFormatFn(_value) : _value;
      const jsonValue = JSON.parse(_value);
      matches[_key] = jsonValue;
    } catch (error) {
      matches[_key] = _value;
    }
  }

  return matches;
}

function parseHeaders(headers) {
  if (!headers) return {};

  const parsed = {};
  let key;
  let val;
  let i;

  headers &&
    headers.split('\n').forEach(function parser(line) {
      i = line.indexOf(':');
      key = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();

      if (!key) {
        return;
      }

      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    });

  return parsed;
}

function parseBody(body, contentType, valueFormatFn) {
  if (contentType === 'text/plain' || !body) {
    return body;
  }

  const parsed = parseString(body, valueFormatFn);

  switch (contentType) {
    case 'multipart/form-data':
      return Object.keys(parsed).reduce((p, c) => {
        p.append(c, parsed[c]);
        return p;
      }, new FormData());
    case 'application/x-www-form-urlencoded':
      return Object.keys(parsed).reduce((p, c) => {
        return p ? `${p}&${c}=${parsed[c]}` : `${c}=${parsed[c]}`;
      });
  }

  return parsed;
}

function formatBodyFun(contentType, body) {
  if (!body) return {};
  switch (contentType) {
    case 'application/json':
      return { json: body };
    case 'multipart/form-data':
      return { form: body };
    case 'application/x-www-form-urlencoded':
      return { body };
  }
  return {};
}

function formatNotifyContentFun(url, body, title, content) {
  if (!url.includes('$title') && !body.includes('$title')) {
    return {};
  }

  return {
    formatUrl: url
      .replaceAll('$title', encodeURIComponent(title))
      .replaceAll('$content', encodeURIComponent(content)),
    formatBody: body
      .replaceAll('$title', title)
      .replaceAll('$content', content),
  };
}

module.exports = {
  sendNotify,
  BARK_PUSH,
};

// prettier-ignore
function Env(t, s) { return new class { constructor(t, s) { this.name = t, this.data = null, this.dataFile = "box.dat", this.logs = [], this.logSeparator = "\n", this.startTime = (new Date).getTime(), Object.assign(this, s), this.log("", `\ud83d\udd14${this.name}, \u5f00\u59cb!`) } isNode() { return "undefined" != typeof module && !!module.exports } isQuanX() { return "undefined" != typeof $task } isSurge() { return "undefined" != typeof $httpClient && "undefined" == typeof $loon } isLoon() { return "undefined" != typeof $loon } getScript(t) { return new Promise(s => { $.get({ url: t }, (t, e, i) => s(i)) }) } runScript(t, s) { return new Promise(e => { let i = this.getdata("@chavy_boxjs_userCfgs.httpapi"); i = i ? i.replace(/\n/g, "").trim() : i; let o = this.getdata("@chavy_boxjs_userCfgs.httpapi_timeout"); o = o ? 1 * o : 20, o = s && s.timeout ? s.timeout : o; const [h, a] = i.split("@"), r = { url: `http://${a}/v1/scripting/evaluate`, body: { script_text: t, mock_type: "cron", timeout: o }, headers: { "X-Key": h, Accept: "*/*" } }; $.post(r, (t, s, i) => e(i)) }).catch(t => this.logErr(t)) } loaddata() { if (!this.isNode()) return {}; { this.fs = this.fs ? this.fs : require("fs"), this.path = this.path ? this.path : require("path"); const t = this.path.resolve(this.dataFile), s = this.path.resolve(process.cwd(), this.dataFile), e = this.fs.existsSync(t), i = !e && this.fs.existsSync(s); if (!e && !i) return {}; { const i = e ? t : s; try { return JSON.parse(this.fs.readFileSync(i)) } catch (t) { return {} } } } } writedata() { if (this.isNode()) { this.fs = this.fs ? this.fs : require("fs"), this.path = this.path ? this.path : require("path"); const t = this.path.resolve(this.dataFile), s = this.path.resolve(process.cwd(), this.dataFile), e = this.fs.existsSync(t), i = !e && this.fs.existsSync(s), o = JSON.stringify(this.data); e ? this.fs.writeFileSync(t, o) : i ? this.fs.writeFileSync(s, o) : this.fs.writeFileSync(t, o) } } lodash_get(t, s, e) { const i = s.replace(/\[(\d+)\]/g, ".$1").split("."); let o = t; for (const t of i) if (o = Object(o)[t], void 0 === o) return e; return o } lodash_set(t, s, e) { return Object(t) !== t ? t : (Array.isArray(s) || (s = s.toString().match(/[^.[\]]+/g) || []), s.slice(0, -1).reduce((t, e, i) => Object(t[e]) === t[e] ? t[e] : t[e] = Math.abs(s[i + 1]) >> 0 == +s[i + 1] ? [] : {}, t)[s[s.length - 1]] = e, t) } getdata(t) { let s = this.getval(t); if (/^@/.test(t)) { const [, e, i] = /^@(.*?)\.(.*?)$/.exec(t), o = e ? this.getval(e) : ""; if (o) try { const t = JSON.parse(o); s = t ? this.lodash_get(t, i, "") : s } catch (t) { s = "" } } return s } setdata(t, s) { let e = !1; if (/^@/.test(s)) { const [, i, o] = /^@(.*?)\.(.*?)$/.exec(s), h = this.getval(i), a = i ? "null" === h ? null : h || "{}" : "{}"; try { const s = JSON.parse(a); this.lodash_set(s, o, t), e = this.setval(JSON.stringify(s), i) } catch (s) { const h = {}; this.lodash_set(h, o, t), e = this.setval(JSON.stringify(h), i) } } else e = $.setval(t, s); return e } getval(t) { return this.isSurge() || this.isLoon() ? $persistentStore.read(t) : this.isQuanX() ? $prefs.valueForKey(t) : this.isNode() ? (this.data = this.loaddata(), this.data[t]) : this.data && this.data[t] || null } setval(t, s) { return this.isSurge() || this.isLoon() ? $persistentStore.write(t, s) : this.isQuanX() ? $prefs.setValueForKey(t, s) : this.isNode() ? (this.data = this.loaddata(), this.data[s] = t, this.writedata(), !0) : this.data && this.data[s] || null } initGotEnv(t) { this.got = this.got ? this.got : require("got"), this.cktough = this.cktough ? this.cktough : require("tough-cookie"), this.ckjar = this.ckjar ? this.ckjar : new this.cktough.CookieJar, t && (t.headers = t.headers ? t.headers : {}, void 0 === t.headers.Cookie && void 0 === t.cookieJar && (t.cookieJar = this.ckjar)) } get(t, s = (() => { })) { t.headers && (delete t.headers["Content-Type"], delete t.headers["Content-Length"]), this.isSurge() || this.isLoon() ? $httpClient.get(t, (t, e, i) => { !t && e && (e.body = i, e.statusCode = e.status), s(t, e, i) }) : this.isQuanX() ? $task.fetch(t).then(t => { const { statusCode: e, statusCode: i, headers: o, body: h } = t; s(null, { status: e, statusCode: i, headers: o, body: h }, h) }, t => s(t)) : this.isNode() && (this.initGotEnv(t), this.got(t).on("redirect", (t, s) => { try { const e = t.headers["set-cookie"].map(this.cktough.Cookie.parse).toString(); this.ckjar.setCookieSync(e, null), s.cookieJar = this.ckjar } catch (t) { this.logErr(t) } }).then(t => { const { statusCode: e, statusCode: i, headers: o, body: h } = t; s(null, { status: e, statusCode: i, headers: o, body: h }, h) }, t => s(t))) } post(t, s = (() => { })) { if (t.body && t.headers && !t.headers["Content-Type"] && (t.headers["Content-Type"] = "application/x-www-form-urlencoded"), delete t.headers["Content-Length"], this.isSurge() || this.isLoon()) $httpClient.post(t, (t, e, i) => { !t && e && (e.body = i, e.statusCode = e.status), s(t, e, i) }); else if (this.isQuanX()) t.method = "POST", $task.fetch(t).then(t => { const { statusCode: e, statusCode: i, headers: o, body: h } = t; s(null, { status: e, statusCode: i, headers: o, body: h }, h) }, t => s(t)); else if (this.isNode()) { this.initGotEnv(t); const { url: e, ...i } = t; this.got.post(e, i).then(t => { const { statusCode: e, statusCode: i, headers: o, body: h } = t; s(null, { status: e, statusCode: i, headers: o, body: h }, h) }, t => s(t)) } } time(t) { let s = { "M+": (new Date).getMonth() + 1, "d+": (new Date).getDate(), "H+": (new Date).getHours(), "m+": (new Date).getMinutes(), "s+": (new Date).getSeconds(), "q+": Math.floor(((new Date).getMonth() + 3) / 3), S: (new Date).getMilliseconds() }; /(y+)/.test(t) && (t = t.replace(RegExp.$1, ((new Date).getFullYear() + "").substr(4 - RegExp.$1.length))); for (let e in s) new RegExp("(" + e + ")").test(t) && (t = t.replace(RegExp.$1, 1 == RegExp.$1.length ? s[e] : ("00" + s[e]).substr(("" + s[e]).length))); return t } msg(s = t, e = "", i = "", o) { const h = t => !t || !this.isLoon() && this.isSurge() ? t : "string" == typeof t ? this.isLoon() ? t : this.isQuanX() ? { "open-url": t } : void 0 : "object" == typeof t && (t["open-url"] || t["media-url"]) ? this.isLoon() ? t["open-url"] : this.isQuanX() ? t : void 0 : void 0; $.isMute || (this.isSurge() || this.isLoon() ? $notification.post(s, e, i, h(o)) : this.isQuanX() && $notify(s, e, i, h(o))), this.logs.push("", "==============\ud83d\udce3\u7cfb\u7edf\u901a\u77e5\ud83d\udce3=============="), this.logs.push(s), e && this.logs.push(e), i && this.logs.push(i) } log(...t) { t.length > 0 ? this.logs = [...this.logs, ...t] : console.log(this.logs.join(this.logSeparator)) } logErr(t, s) { const e = !this.isSurge() && !this.isQuanX() && !this.isLoon(); e ? $.log("", `\u2757\ufe0f${this.name}, \u9519\u8bef!`, t.stack) : $.log("", `\u2757\ufe0f${this.name}, \u9519\u8bef!`, t) } wait(t) { return new Promise(s => setTimeout(s, t)) } done(t = {}) { const s = (new Date).getTime(), e = (s - this.startTime) / 1e3; this.log("", `\ud83d\udd14${this.name}, \u7ed3\u675f! \ud83d\udd5b ${e} \u79d2`), this.log(), (this.isSurge() || this.isQuanX() || this.isLoon()) && $done(t) } }(t, s) }
~~~